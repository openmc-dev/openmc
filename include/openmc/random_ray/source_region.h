#ifndef OPENMC_RANDOM_RAY_SOURCE_REGION_H
#define OPENMC_RANDOM_RAY_SOURCE_REGION_H

#include "openmc/openmp_interface.h"
#include "openmc/position.h"
#include "openmc/random_ray/moment_matrix.h"
#include "openmc/random_ray/random_ray.h"

namespace openmc {

//----------------------------------------------------------------------------
// Helper Functions

// The hash_combine function is the standard hash combine function from boost
// that is typically used for combining multiple hash values into a single hash
// as is needed for larger objects being stored in a hash map. The function is
// taken from:
// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine
// which carries the following license:
//
// Boost Software License - Version 1.0 - August 17th, 2003
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
inline void hash_combine(size_t& seed, const size_t v)
{
  seed ^= (v + 0x9e3779b9 + (seed << 6) + (seed >> 2));
}

//----------------------------------------------------------------------------
// Helper Structs

// A mapping object that is used to map between a specific random ray
// source region and an OpenMC native tally bin that it should score to
// every iteration.
struct TallyTask {
  int tally_idx;
  int filter_idx;
  int score_idx;
  int score_type;
  TallyTask(int tally_idx, int filter_idx, int score_idx, int score_type)
    : tally_idx(tally_idx), filter_idx(filter_idx), score_idx(score_idx),
      score_type(score_type)
  {}
  TallyTask() = default;

  // Comparison and Hash operators are defined to allow usage of the
  // TallyTask struct as a key in an unordered_set
  bool operator==(const TallyTask& other) const
  {
    return tally_idx == other.tally_idx && filter_idx == other.filter_idx &&
           score_idx == other.score_idx && score_type == other.score_type;
  }

  struct HashFunctor {
    size_t operator()(const TallyTask& task) const
    {
      size_t seed = 0;
      hash_combine(seed, task.tally_idx);
      hash_combine(seed, task.filter_idx);
      hash_combine(seed, task.score_idx);
      hash_combine(seed, task.score_type);
      return seed;
    }
  };
};

class SourceRegion {
public:
  //----------------------------------------------------------------------------
  // Constructors
  SourceRegion(int negroups)
  {
    if (settings::run_mode == RunMode::EIGENVALUE) {
      // If in eigenvalue mode, set starting flux to guess of 1
      scalar_flux_old_.assign(negroups, 1.0);
    } else {
      // If in fixed source mode, set starting flux to guess of zero
      // and initialize external source arrays
      scalar_flux_old_.assign(negroups, 0.0);
      external_source_.assign(negroups, 0.0);
    }

    scalar_flux_new_.assign(negroups, 0.0);
    source_.resize(negroups);
    scalar_flux_final_.assign(negroups, 0.0);

    tally_task_.resize(negroups);

    if (RandomRay::source_shape_ != RandomRaySourceShape::FLAT) {
      source_gradients_.resize(negroups);
      flux_moments_old_.resize(negroups);
      flux_moments_new_.resize(negroups);
      flux_moments_t_.resize(negroups);
    }
  }

  //----------------------------------------------------------------------------
  // Public Data members

  // Scalar fields specific to this source region
  int material_ {0};
  OpenMPMutex lock_;
  double volume_ {0.0};
  double volume_t_ {0.0};
  double volume_naive_ {0.0};
  int position_recorded_ {0};
  bool external_source_present_ {false};
  Position position_ {0.0, 0.0, 0.0};
  Position centroid_ {0.0, 0.0, 0.0};
  Position centroid_iteration_ {0.0, 0.0, 0.0};
  Position centroid_t_ {0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_t_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

  // 1D arrays storing energy group-wise values
  vector<double> scalar_flux_old_;
  vector<double> scalar_flux_new_;
  vector<float> source_;
  vector<float> external_source_;
  vector<double> scalar_flux_final_;

  vector<MomentArray> source_gradients_;
  vector<MomentArray> flux_moments_old_;
  vector<MomentArray> flux_moments_new_;
  vector<MomentArray> flux_moments_t_;

  // 2D array representing values for all energy groups x tally
  // tasks
  vector<vector<TallyTask>> tally_task_;

}; // class SourceRegion

} // namespace openmc

#endif // OPENMC_RANDOM_RAY_SOURCE_REGION_H