#ifndef OPENMC_RANDOM_RAY_SOURCE_REGION_H
#define OPENMC_RANDOM_RAY_SOURCE_REGION_H

#include "openmc/openmp_interface.h"
#include "openmc/position.h"
#include "openmc/random_ray/moment_matrix.h"
#include "openmc/settings.h"

namespace openmc {

//----------------------------------------------------------------------------
// Helper Functions

// The hash_combine function is the standard hash combine function from boost
// that is typically used for combining multiple hash values into a single hash
// as is needed for larger objects being stored in a hash map. The function is
// taken from:
// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine
// which carries the following license:
//
// Boost Software License - Version 1.0 - August 17th, 2003
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
inline void hash_combine(size_t& seed, const size_t v)
{
  seed ^= (v + 0x9e3779b9 + (seed << 6) + (seed >> 2));
}

//----------------------------------------------------------------------------
// Helper Structs

// A mapping object that is used to map between a specific random ray
// source region and an OpenMC native tally bin that it should score to
// every iteration.
struct TallyTask {
  int tally_idx;
  int filter_idx;
  int score_idx;
  int score_type;
  TallyTask(int tally_idx, int filter_idx, int score_idx, int score_type)
    : tally_idx(tally_idx), filter_idx(filter_idx), score_idx(score_idx),
      score_type(score_type)
  {}
  TallyTask() = default;

  // Comparison and Hash operators are defined to allow usage of the
  // TallyTask struct as a key in an unordered_set
  bool operator==(const TallyTask& other) const
  {
    return tally_idx == other.tally_idx && filter_idx == other.filter_idx &&
           score_idx == other.score_idx && score_type == other.score_type;
  }

  struct HashFunctor {
    size_t operator()(const TallyTask& task) const
    {
      size_t seed = 0;
      hash_combine(seed, task.tally_idx);
      hash_combine(seed, task.filter_idx);
      hash_combine(seed, task.score_idx);
      hash_combine(seed, task.score_type);
      return seed;
    }
  };
};

class SourceRegion {
public:
  //----------------------------------------------------------------------------
  // Constructors
  SourceRegion(int negroups, bool is_linear)
  {
    if (settings::run_mode == RunMode::EIGENVALUE) {
      // If in eigenvalue mode, set starting flux to guess of 1
      scalar_flux_old_.assign(negroups, 1.0);
    } else {
      // If in fixed source mode, set starting flux to guess of zero
      // and initialize external source arrays
      scalar_flux_old_.assign(negroups, 0.0);
      external_source_.assign(negroups, 0.0);
    }

    scalar_flux_new_.assign(negroups, 0.0);
    source_.resize(negroups);
    scalar_flux_final_.assign(negroups, 0.0);

    tally_task_.resize(negroups);

    if (is_linear) {
      source_gradients_.resize(negroups);
      flux_moments_old_.resize(negroups);
      flux_moments_new_.resize(negroups);
      flux_moments_t_.resize(negroups);
    }
  }

  //----------------------------------------------------------------------------
  // Public Data members

  // Scalar fields specific to this source region
  int material_ {0};
  OpenMPMutex lock_;
  double volume_ {0.0};
  double volume_t_ {0.0};
  double volume_naive_ {0.0};
  int position_recorded_ {0};
  bool external_source_present_ {false};
  Position position_ {0.0, 0.0, 0.0};
  Position centroid_ {0.0, 0.0, 0.0};
  Position centroid_iteration_ {0.0, 0.0, 0.0};
  Position centroid_t_ {0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_t_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

  // 1D arrays storing energy group-wise values
  vector<double> scalar_flux_old_;
  vector<double> scalar_flux_new_;
  vector<float> source_;
  vector<float> external_source_;
  vector<double> scalar_flux_final_;

  vector<MomentArray> source_gradients_;
  vector<MomentArray> flux_moments_old_;
  vector<MomentArray> flux_moments_new_;
  vector<MomentArray> flux_moments_t_;

  // 2D array representing values for all energy groups x tally
  // tasks
  vector<vector<TallyTask>> tally_task_;

}; // class SourceRegion

class SourceRegionContainer {
public:
  //----------------------------------------------------------------------------
  // Constructors
  SourceRegionContainer(int negroups, bool is_linear)
    : negroups_(negroups), is_linear_(is_linear)
  {}

  //----------------------------------------------------------------------------
  // Accessors
  int& material(int sr) { return material_[sr]; }
  const int& material(int sr) const { return material_[sr]; }

  OpenMPMutex& lock(int sr) { return lock_[sr]; }
  const OpenMPMutex& lock(int sr) const { return lock_[sr]; }

  double& volume(int sr) { return volume_[sr]; }
  const double& volume(int sr) const { return volume_[sr]; }

  double& volume_t(int sr) { return volume_t_[sr]; }
  const double& volume_t(int sr) const { return volume_t_[sr]; }

  double& volume_naive(int sr) { return volume_naive_[sr]; }
  const double& volume_naive(int sr) const
  {
    return volume_naive_[sr];
  }

  int& position_recorded(int sr) { return position_recorded_[sr]; }
  const int& position_recorded(int sr) const
  {
    return position_recorded_[sr];
  }

  bool& external_source_present(int sr)
  {
    return external_source_present_[sr];
  }
  const bool& external_source_present(int sr) const
  {
    return external_source_present_[sr];
  }

  Position& position(int sr) { return position_[sr]; }
  const Position& position(int sr) const { return position_[sr]; }

  // Conditional field accessors (only if is_linear_)
  Position& centroid(int sr) { return centroid_[sr]; }
  const Position& centroid(int sr) const { return centroid_[sr]; }

  Position& centroid_iteration(int sr)
  {
    return centroid_iteration_[sr];
  }
  const Position& centroid_iteration(int sr) const
  {
    return centroid_iteration_[sr];
  }

  Position& centroid_t(int sr) { return centroid_t_[sr]; }
  const Position& centroid_t(int sr) const { return centroid_t_[sr]; }

  MomentMatrix& mom_matrix(int sr) { return mom_matrix_[sr]; }
  const MomentMatrix& mom_matrix(int sr) const
  {
    return mom_matrix_[sr];
  }

  MomentMatrix& mom_matrix_t(int sr) { return mom_matrix_t_[sr]; }
  const MomentMatrix& mom_matrix_t(int sr) const
  {
    return mom_matrix_t_[sr];
  }

  MomentArray& source_gradients(int sr, int g)
  {
    return source_gradients_[index(sr, g)];
  }
  const MomentArray& source_gradients(int sr, int g) const
  {
    return source_gradients_[index(sr, g)];
  }

  MomentArray& flux_moments_old(int sr, int g)
  {
    return flux_moments_old_[index(sr, g)];
  }
  const MomentArray& flux_moments_old(int sr, int g) const
  {
    return flux_moments_old_[index(sr, g)];
  }

  MomentArray& flux_moments_new(int sr, int g)
  {
    return flux_moments_new_[index(sr, g)];
  }
  const MomentArray& flux_moments_new(int sr, int g) const
  {
    return flux_moments_new_[index(sr, g)];
  }

  MomentArray& flux_moments_t(int sr, int g)
  {
    return flux_moments_t_[index(sr, g)];
  }
  const MomentArray& flux_moments_t(int sr, int g) const
  {
    return flux_moments_t_[index(sr, g)];
  }

  // Energy-dependent field accessors
  double& scalar_flux_old(int sr, int g)
  {
    return scalar_flux_old_[index(sr, g)];
  }
  const double& scalar_flux_old(int sr, int g) const
  {
    return scalar_flux_old_[index(sr, g)];
  }

  double& scalar_flux_new(int sr, int g)
  {
    return scalar_flux_new_[index(sr, g)];
  }
  const double& scalar_flux_new(int sr, int g) const
  {
    return scalar_flux_new_[index(sr, g)];
  }

  double& scalar_flux_final(int sr, int g)
  {
    return scalar_flux_final_[index(sr, g)];
  }
  const double& scalar_flux_final(int sr, int g) const
  {
    return scalar_flux_final_[index(sr, g)];
  }

  float& source(int sr, int g) { return source_[index(sr, g)]; }
  const float& source(int sr, int g) const
  {
    return source_[index(sr, g)];
  }

  float& external_source(int sr, int g)
  {
    return external_source_[index(sr, g)];
  }
  const float& external_source(int sr, int g) const
  {
    return external_source_[index(sr, g)];
  }

  // Tally task accessors
  vector<TallyTask>& tally_task(int sr, int g)
  {
    return tally_task_[index(sr, g)];
  }
  const vector<TallyTask>& tally_task(int sr, int g) const
  {
    return tally_task_[index(sr, g)];
  }

  //----------------------------------------------------------------------------
  // Public Methods

  void push_back(const SourceRegion& sr)
  {
    int sr = num_regions_++;

    // Scalar fields
    material_.push_back(sr.material_);
    lock_.push_back(sr.lock_);
    volume_.push_back(sr.volume_);
    volume_t_.push_back(sr.volume_t_);
    volume_naive_.push_back(sr.volume_naive_);
    position_recorded_.push_back(sr.position_recorded_);
    external_source_present_.push_back(sr.external_source_present_);
    position_.push_back(sr.position_);

    // Only store these fields if is_linear_ is true
    if (is_linear_) {
      centroid_.push_back(sr.centroid_);
      centroid_iteration_.push_back(sr.centroid_iteration_);
      centroid_t_.push_back(sr.centroid_t_);
      mom_matrix_.push_back(sr.mom_matrix_);
      mom_matrix_t_.push_back(sr.mom_matrix_t_);
    }

    // Energy-dependent fields
    for (int g = 0; g < negroups_; ++g) {
      scalar_flux_old_.push_back(sr.scalar_flux_old_[g]);
      scalar_flux_new_.push_back(sr.scalar_flux_new_[g]);
      scalar_flux_final_.push_back(sr.scalar_flux_final_[g]);
      source_.push_back(sr.source_[g]);
      external_source_.push_back(sr.external_source_[g]);

      // Only store these fields if is_linear_ is true
      if (is_linear_) {
        source_gradients_.push_back(sr.source_gradients_[g]);
        flux_moments_old_.push_back(sr.flux_moments_old_[g]);
        flux_moments_new_.push_back(sr.flux_moments_new_[g]);
        flux_moments_t_.push_back(sr.flux_moments_t_[g]);
      }

      // Tally tasks
      tally_task_.emplace_back(sr.tally_task_[g]);
    }
  }

  void resize(int n_source_regions, const SourceRegion& source_region)
  {
    // Clear existing data
    num_regions_ = 0;

    // Reserve space for efficiency
    material_.reserve(n_source_regions);
    lock_.reserve(n_source_regions);
    volume_.reserve(n_source_regions);
    volume_t_.reserve(n_source_regions);
    volume_naive_.reserve(n_source_regions);
    position_recorded_.reserve(n_source_regions);
    external_source_present_.reserve(n_source_regions);
    position_.reserve(n_source_regions);

    if (is_linear_) {
      centroid_.reserve(n_source_regions);
      centroid_iteration_.reserve(n_source_regions);
      centroid_t_.reserve(n_source_regions);
      mom_matrix_.reserve(n_source_regions);
      mom_matrix_t_.reserve(n_source_regions);
    }

    scalar_flux_old_.reserve(n_source_regions * negroups_);
    scalar_flux_new_.reserve(n_source_regions * negroups_);
    scalar_flux_final_.reserve(n_source_regions * negroups_);
    source_.reserve(n_source_regions * negroups_);
    external_source_.reserve(n_source_regions * negroups_);

    if (is_linear_) {
      source_gradients_.reserve(n_source_regions * negroups_);
      flux_moments_old_.reserve(n_source_regions * negroups_);
      flux_moments_new_.reserve(n_source_regions * negroups_);
      flux_moments_t_.reserve(n_source_regions * negroups_);
    }

    tally_task_.reserve(n_source_regions * negroups_);

    // Fill with copies of source_region
    for (int i = 0; i < n_source_regions; ++i) {
      push_back(source_region);
    }
  }

private:
  //----------------------------------------------------------------------------
  // Private Data Members
  int negroups_;
  bool is_linear_;
  int num_regions_ = 0;

  // SoA storage for scalar fields
  vector<int> material_;
  vector<OpenMPMutex> lock_;
  vector<double> volume_;
  vector<double> volume_t_;
  vector<double> volume_naive_;
  vector<int> position_recorded_;
  vector<bool> external_source_present_;
  vector<Position> position_;
  vector<Position> centroid_;
  vector<Position> centroid_iteration_;
  vector<Position> centroid_t_;
  vector<MomentMatrix> mom_matrix_;
  vector<MomentMatrix> mom_matrix_t_;

  // Flattened 1D storage for energy-dependent fields
  vector<double> scalar_flux_old_;
  vector<double> scalar_flux_new_;
  vector<double> scalar_flux_final_;
  vector<float> source_;
  vector<float> external_source_;
  vector<MomentArray> source_gradients_;
  vector<MomentArray> flux_moments_old_;
  vector<MomentArray> flux_moments_new_;
  vector<MomentArray> flux_moments_t_;

  // Tally tasks
  vector<vector<TallyTask>> tally_task_;

  // Helper function for indexing
  inline int index(int sr, int g) const { return sr * negroups_ + g; }
};

} // namespace openmc

#endif // OPENMC_RANDOM_RAY_SOURCE_REGION_H