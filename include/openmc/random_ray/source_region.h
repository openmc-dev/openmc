#ifndef OPENMC_RANDOM_RAY_SOURCE_REGION_H
#define OPENMC_RANDOM_RAY_SOURCE_REGION_H

#include "openmc/openmp_interface.h"
#include "openmc/position.h"
#include "openmc/random_ray/moment_matrix.h"
#include "openmc/settings.h"

namespace openmc {

//----------------------------------------------------------------------------
// Helper Functions

// The hash_combine function is the standard hash combine function from boost
// that is typically used for combining multiple hash values into a single hash
// as is needed for larger objects being stored in a hash map. The function is
// taken from:
// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine
// which carries the following license:
//
// Boost Software License - Version 1.0 - August 17th, 2003
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
inline void hash_combine(size_t& seed, const size_t v)
{
  seed ^= (v + 0x9e3779b9 + (seed << 6) + (seed >> 2));
}

//----------------------------------------------------------------------------
// Helper Structs

// A mapping object that is used to map between a specific random ray
// source region and an OpenMC native tally bin that it should score to
// every iteration.
struct TallyTask {
  int tally_idx;
  int filter_idx;
  int score_idx;
  int score_type;
  TallyTask(int tally_idx, int filter_idx, int score_idx, int score_type)
    : tally_idx(tally_idx), filter_idx(filter_idx), score_idx(score_idx),
      score_type(score_type)
  {}
  TallyTask() = default;

  // Comparison and Hash operators are defined to allow usage of the
  // TallyTask struct as a key in an unordered_set
  bool operator==(const TallyTask& other) const
  {
    return tally_idx == other.tally_idx && filter_idx == other.filter_idx &&
           score_idx == other.score_idx && score_type == other.score_type;
  }

  struct HashFunctor {
    size_t operator()(const TallyTask& task) const
    {
      size_t seed = 0;
      hash_combine(seed, task.tally_idx);
      hash_combine(seed, task.filter_idx);
      hash_combine(seed, task.score_idx);
      hash_combine(seed, task.score_type);
      return seed;
    }
  };
};

class SourceRegion {
public:
  //----------------------------------------------------------------------------
  // Constructors
  SourceRegion(int negroups, bool is_linear);
  SourceRegion() = default;

  //----------------------------------------------------------------------------
  // Public Data members

  // Scalar fields
  int material_ {0};
  OpenMPMutex lock_;
  double volume_ {0.0};
  double volume_t_ {0.0};
  double volume_sq_ {0.0};
  double volume_sq_t_ {0.0};
  double volume_naive_ {0.0};
  int position_recorded_ {0};
  int external_source_present_ {0};
  Position position_ {0.0, 0.0, 0.0};
  Position centroid_ {0.0, 0.0, 0.0};
  Position centroid_iteration_ {0.0, 0.0, 0.0};
  Position centroid_t_ {0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  MomentMatrix mom_matrix_t_ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  // A set of volume tally tasks. This more complicated data structure is
  // convenient for ensuring that volumes are only tallied once per source
  // region, regardless of how many energy groups are used for tallying.
  std::unordered_set<TallyTask, TallyTask::HashFunctor> volume_task_;

  // Energy group-wise 1D arrays
  vector<double> scalar_flux_old_;
  vector<double> scalar_flux_new_;
  vector<float> source_;
  vector<float> external_source_;
  vector<double> scalar_flux_final_;

  vector<MomentArray> source_gradients_;
  vector<MomentArray> flux_moments_old_;
  vector<MomentArray> flux_moments_new_;
  vector<MomentArray> flux_moments_t_;

  // 2D array representing values for all energy groups x tally
  // tasks. Each group may have a different number of tally tasks
  // associated with it, necessitating the use of a jagged array.
  vector<vector<TallyTask>> tally_task_;

}; // class SourceRegion

class SourceRegionContainer {
public:
  //----------------------------------------------------------------------------
  // Constructors
  SourceRegionContainer(int negroups, bool is_linear)
    : negroups_(negroups), is_linear_(is_linear)
  {}
  SourceRegionContainer() = default;

  //----------------------------------------------------------------------------
  // Public Accessors
  int& material(int64_t sr) { return material_[sr]; }
  const int& material(int64_t sr) const { return material_[sr]; }

  OpenMPMutex& lock(int64_t sr) { return lock_[sr]; }
  const OpenMPMutex& lock(int64_t sr) const { return lock_[sr]; }

  double& volume(int64_t sr) { return volume_[sr]; }
  const double& volume(int64_t sr) const { return volume_[sr]; }

  double& volume_t(int64_t sr) { return volume_t_[sr]; }
  const double& volume_t(int64_t sr) const { return volume_t_[sr]; }

  double& volume_sq(int64_t sr) { return volume_sq_[sr]; }
  const double& volume_sq(int64_t sr) const { return volume_sq_[sr]; }

  double& volume_sq_t(int64_t sr) { return volume_sq_t_[sr]; }
  const double& volume_sq_t(int64_t sr) const { return volume_sq_t_[sr]; }

  double& volume_naive(int64_t sr) { return volume_naive_[sr]; }
  const double& volume_naive(int64_t sr) const { return volume_naive_[sr]; }

  int& position_recorded(int64_t sr) { return position_recorded_[sr]; }
  const int& position_recorded(int64_t sr) const
  {
    return position_recorded_[sr];
  }

  int& external_source_present(int64_t sr)
  {
    return external_source_present_[sr];
  }
  const int& external_source_present(int64_t sr) const
  {
    return external_source_present_[sr];
  }

  Position& position(int64_t sr) { return position_[sr]; }
  const Position& position(int64_t sr) const { return position_[sr]; }

  Position& centroid(int64_t sr) { return centroid_[sr]; }
  const Position& centroid(int64_t sr) const { return centroid_[sr]; }

  Position& centroid_iteration(int64_t sr) { return centroid_iteration_[sr]; }
  const Position& centroid_iteration(int64_t sr) const
  {
    return centroid_iteration_[sr];
  }

  Position& centroid_t(int64_t sr) { return centroid_t_[sr]; }
  const Position& centroid_t(int64_t sr) const { return centroid_t_[sr]; }

  MomentMatrix& mom_matrix(int64_t sr) { return mom_matrix_[sr]; }
  const MomentMatrix& mom_matrix(int64_t sr) const { return mom_matrix_[sr]; }

  MomentMatrix& mom_matrix_t(int64_t sr) { return mom_matrix_t_[sr]; }
  const MomentMatrix& mom_matrix_t(int64_t sr) const
  {
    return mom_matrix_t_[sr];
  }

  MomentArray& source_gradients(int64_t sr, int g)
  {
    return source_gradients_[index(sr, g)];
  }
  const MomentArray& source_gradients(int64_t sr, int g) const
  {
    return source_gradients_[index(sr, g)];
  }
  MomentArray& source_gradients(int64_t se) { return source_gradients_[se]; }
  const MomentArray& source_gradients(int64_t se) const
  {
    return source_gradients_[se];
  }

  MomentArray& flux_moments_old(int64_t sr, int g)
  {
    return flux_moments_old_[index(sr, g)];
  }
  const MomentArray& flux_moments_old(int64_t sr, int g) const
  {
    return flux_moments_old_[index(sr, g)];
  }
  MomentArray& flux_moments_old(int64_t se) { return flux_moments_old_[se]; }
  const MomentArray& flux_moments_old(int64_t se) const
  {
    return flux_moments_old_[se];
  }

  MomentArray& flux_moments_new(int64_t sr, int g)
  {
    return flux_moments_new_[index(sr, g)];
  }
  const MomentArray& flux_moments_new(int64_t sr, int g) const
  {
    return flux_moments_new_[index(sr, g)];
  }
  MomentArray& flux_moments_new(int64_t se) { return flux_moments_new_[se]; }
  const MomentArray& flux_moments_new(int64_t se) const
  {
    return flux_moments_new_[se];
  }

  MomentArray& flux_moments_t(int64_t sr, int g)
  {
    return flux_moments_t_[index(sr, g)];
  }
  const MomentArray& flux_moments_t(int64_t sr, int g) const
  {
    return flux_moments_t_[index(sr, g)];
  }
  MomentArray& flux_moments_t(int64_t se) { return flux_moments_t_[se]; }
  const MomentArray& flux_moments_t(int64_t se) const
  {
    return flux_moments_t_[se];
  }

  double& scalar_flux_old(int64_t sr, int g)
  {
    return scalar_flux_old_[index(sr, g)];
  }
  const double& scalar_flux_old(int64_t sr, int g) const
  {
    return scalar_flux_old_[index(sr, g)];
  }
  double& scalar_flux_old(int64_t se) { return scalar_flux_old_[se]; }
  const double& scalar_flux_old(int64_t se) const
  {
    return scalar_flux_old_[se];
  }

  double& scalar_flux_new(int64_t sr, int g)
  {
    return scalar_flux_new_[index(sr, g)];
  }
  const double& scalar_flux_new(int64_t sr, int g) const
  {
    return scalar_flux_new_[index(sr, g)];
  }
  double& scalar_flux_new(int64_t se) { return scalar_flux_new_[se]; }
  const double& scalar_flux_new(int64_t se) const
  {
    return scalar_flux_new_[se];
  }

  double& scalar_flux_final(int64_t sr, int g)
  {
    return scalar_flux_final_[index(sr, g)];
  }
  const double& scalar_flux_final(int64_t sr, int g) const
  {
    return scalar_flux_final_[index(sr, g)];
  }
  double& scalar_flux_final(int64_t se) { return scalar_flux_final_[se]; }
  const double& scalar_flux_final(int64_t se) const
  {
    return scalar_flux_final_[se];
  }

  float& source(int64_t sr, int g) { return source_[index(sr, g)]; }
  const float& source(int64_t sr, int g) const { return source_[index(sr, g)]; }
  float& source(int64_t se) { return source_[se]; }
  const float& source(int64_t se) const { return source_[se]; }

  float& external_source(int64_t sr, int g)
  {
    return external_source_[index(sr, g)];
  }
  const float& external_source(int64_t sr, int g) const
  {
    return external_source_[index(sr, g)];
  }
  float& external_source(int64_t se) { return external_source_[se]; }
  const float& external_source(int64_t se) const
  {
    return external_source_[se];
  }

  vector<TallyTask>& tally_task(int64_t sr, int g)
  {
    return tally_task_[index(sr, g)];
  }
  const vector<TallyTask>& tally_task(int64_t sr, int g) const
  {
    return tally_task_[index(sr, g)];
  }
  vector<TallyTask>& tally_task(int64_t se) { return tally_task_[se]; }
  const vector<TallyTask>& tally_task(int64_t se) const
  {
    return tally_task_[se];
  }

  std::unordered_set<TallyTask, TallyTask::HashFunctor>& volume_task(int64_t sr)
  {
    return volume_task_[sr];
  }
  const std::unordered_set<TallyTask, TallyTask::HashFunctor>& volume_task(
    int64_t sr) const
  {
    return volume_task_[sr];
  }

  //----------------------------------------------------------------------------
  // Public Methods

  void push_back(const SourceRegion& sr);
  void assign(int n_source_regions, const SourceRegion& source_region);
  void flux_swap();
  void mpi_sync_ranks(bool reduce_position);

private:
  //----------------------------------------------------------------------------
  // Private Data Members
  int64_t n_source_regions_ {0};
  int negroups_ {0};
  bool is_linear_ {false};

  // SoA storage for scalar fields (one item per source region)
  vector<int> material_;
  vector<OpenMPMutex> lock_;
  vector<double> volume_;
  vector<double> volume_t_;
  vector<double> volume_sq_;
  vector<double> volume_sq_t_;
  vector<double> volume_naive_;
  vector<int> position_recorded_;
  vector<int> external_source_present_;
  vector<Position> position_;
  vector<Position> centroid_;
  vector<Position> centroid_iteration_;
  vector<Position> centroid_t_;
  vector<MomentMatrix> mom_matrix_;
  vector<MomentMatrix> mom_matrix_t_;
  // A set of volume tally tasks. This more complicated data structure is
  // convenient for ensuring that volumes are only tallied once per source
  // region, regardless of how many energy groups are used for tallying.
  vector<std::unordered_set<TallyTask, TallyTask::HashFunctor>> volume_task_;

  // SoA energy group-wise 2D arrays flattened to 1D
  vector<double> scalar_flux_old_;
  vector<double> scalar_flux_new_;
  vector<double> scalar_flux_final_;
  vector<float> source_;
  vector<float> external_source_;

  vector<MomentArray> source_gradients_;
  vector<MomentArray> flux_moments_old_;
  vector<MomentArray> flux_moments_new_;
  vector<MomentArray> flux_moments_t_;

  // SoA 3D array representing values for all source regions x energy groups x
  // tally tasks. The outer two dimensions (source regions and energy groups)
  // are flattened to 1D. Each group may have a different number of tally tasks
  // associated with it, necessitating the use of a jagged array for the inner
  // dimension.
  vector<vector<TallyTask>> tally_task_;

  //----------------------------------------------------------------------------
  // Private Methods

  // Helper function for indexing
  inline int index(int64_t sr, int g) const { return sr * negroups_ + g; }
};

} // namespace openmc

#endif // OPENMC_RANDOM_RAY_SOURCE_REGION_H