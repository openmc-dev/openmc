module initialize

  use ace,              only: read_xs
  use bank_header,      only: Bank
  use constants
  use dict_header,      only: DictIntInt, ElemKeyValueII
  use energy_grid,      only: unionized_grid
  use error,            only: fatal_error
  use geometry,         only: neighbor_lists
  use geometry_header,  only: Cell, Universe, Lattice, BASE_UNIVERSE
  use global
  use input_xml,        only: read_input_xml, read_cross_sections_xml,         &
                              cells_in_univ_dict, read_plots_xml
  use output,           only: title, header, write_summary, print_version,     &
                              print_usage, write_xs_summary, print_plot
  use random_lcg,       only: initialize_prng
  use source,           only: initialize_source
  use state_point,      only: load_state_point
  use string,           only: to_str, str_to_int, starts_with, ends_with
  use tally_header,     only: TallyObject
  use tally_initialize, only: configure_tallies

#ifdef MPI
  use mpi
#endif

#ifdef HDF5
  use hdf5_interface,   only: hdf5_initialize, hdf5_write_summary, &
                              hdf5_load_state_point
#endif

  implicit none

contains

!===============================================================================
! INITIALIZE_RUN takes care of all initialization tasks, i.e. reading
! from command line, reading xml input files, initializing random
! number seeds, reading cross sections, initializing starting source,
! setting up timers, etc.
!===============================================================================

  subroutine initialize_run()

    ! Start total and initialization timer
    call time_total % start()
    call time_initialize % start()

#ifdef MPI
    ! Setup MPI
    call initialize_mpi()
#endif

#ifdef HDF5
    ! Initialize HDF5 interface
    call hdf5_initialize()
#endif

    ! Read command line arguments
    call read_command_line()

    if (master) then
      ! Display title and initialization header
      call title()
      call header("INITIALIZATION", level=1)
    end if

    ! Read XML input files
    call read_input_xml()

    ! Initialize random number generator -- this has to be done after the input
    ! files have been read in case the user specified a seed for the random
    ! number generator

    call initialize_prng()

    ! Read plots.xml if it exists -- this has to be done separate from the other
    ! XML files because we need the PRNG to be initialized first
    if (run_mode == MODE_PLOTTING) call read_plots_xml()

    ! Set up universe structures
    call prepare_universes()

    ! Use dictionaries to redefine index pointers
    call adjust_indices()

    ! After reading input and basic geometry setup is complete, build lists of
    ! neighboring cells for efficient tracking
    call neighbor_lists()

    if (run_mode /= MODE_PLOTTING) then
      ! With the AWRs from the xs_listings, change all material specifications
      ! so that they contain atom percents summing to 1
      call normalize_ao()

      ! Read ACE-format cross sections
      call time_read_xs % start()
      call read_xs()
      call time_read_xs % stop()

      ! Construct unionized energy grid from cross-sections
      if (grid_method == GRID_UNION) then
        call time_unionize % start()
        call unionized_grid()
        call time_unionize % stop()
      end if

      ! Allocate and setup tally stride, matching_bins, and tally maps
      call configure_tallies()

      ! Determine how much work each processor should do
      call calculate_work()

      ! Allocate banks and create source particles -- for a fixed source
      ! calculation, the external source distribution is sampled during the
      ! run, not at initialization
      if (run_mode == MODE_EIGENVALUE) then
        call allocate_banks()
        if (.not. restart_run) call initialize_source()
      end if

      ! If this is a restart run, load the state point data and binary source
      ! file
#ifdef HDF5
      if (restart_run) call hdf5_load_state_point()
#else
      if (restart_run) call load_state_point()
#endif
    end if

    if (master) then
      if (run_mode == MODE_PLOTTING) then
        ! Display plotting information
        call print_plot()
      else
        ! Write summary information
#ifdef HDF5
        if (output_summary) call hdf5_write_summary()
#else
        if (output_summary) call write_summary()
#endif

        ! Write cross section information
        if (output_xs) call write_xs_summary()
      end if
    end if

    ! Stop initialization timer
    call time_initialize % stop()

  end subroutine initialize_run

#ifdef MPI
!===============================================================================
! INITIALIZE_MPI starts up the Message Passing Interface (MPI) and determines
! the number of processors the problem is being run with as well as the rank of
! each processor.
!===============================================================================

  subroutine initialize_mpi()

    integer                   :: bank_blocks(4)  ! Count for each datatype
    integer                   :: bank_types(4)   ! Datatypes
    integer(MPI_ADDRESS_KIND) :: bank_disp(4)    ! Displacements
    integer                   :: temp_type       ! temporary derived type
    integer                   :: result_blocks(1) ! Count for each datatype
    integer                   :: result_types(1)  ! Datatypes
    integer(MPI_ADDRESS_KIND) :: result_disp(1)   ! Displacements
    integer(MPI_ADDRESS_KIND) :: result_base_disp ! Base displacement
    integer(MPI_ADDRESS_KIND) :: lower_bound     ! Lower bound for TallyResult
    integer(MPI_ADDRESS_KIND) :: extent          ! Extent for TallyResult
    type(Bank)       :: b
    type(TallyResult) :: tr

    ! Indicate that MPI is turned on
    mpi_enabled = .true.

    ! Initialize MPI
    call MPI_INIT(mpi_err)

    ! Determine number of processors and rank of each processor
    call MPI_COMM_SIZE(MPI_COMM_WORLD, n_procs, mpi_err)
    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, mpi_err)

    ! Determine master
    if (rank == 0) then
      master = .true.
    else
      master = .false.
    end if

    ! ==========================================================================
    ! CREATE MPI_BANK TYPE

    ! Determine displacements for MPI_BANK type
    call MPI_GET_ADDRESS(b % wgt, bank_disp(1), mpi_err)
    call MPI_GET_ADDRESS(b % xyz, bank_disp(2), mpi_err)
    call MPI_GET_ADDRESS(b % uvw, bank_disp(3), mpi_err)
    call MPI_GET_ADDRESS(b % E,   bank_disp(4), mpi_err)

    ! Adjust displacements 
    bank_disp = bank_disp - bank_disp(1)

    ! Define MPI_BANK for fission sites
    bank_blocks = (/ 1, 3, 3, 1 /)
    bank_types = (/ MPI_REAL8, MPI_REAL8, MPI_REAL8, MPI_REAL8 /)
    call MPI_TYPE_CREATE_STRUCT(4, bank_blocks, bank_disp, & 
         bank_types, MPI_BANK, mpi_err)
    call MPI_TYPE_COMMIT(MPI_BANK, mpi_err)

    ! ==========================================================================
    ! CREATE MPI_TALLYRESULT TYPE

    ! Determine displacements for MPI_BANK type
    call MPI_GET_ADDRESS(tr % value, result_base_disp, mpi_err)
    call MPI_GET_ADDRESS(tr % sum, result_disp(1), mpi_err)

    ! Adjust displacements
    result_disp = result_disp - result_base_disp

    ! Define temporary type for TallyResult
    result_blocks = (/ 2 /)
    result_types = (/ MPI_REAL8 /)
    call MPI_TYPE_CREATE_STRUCT(1, result_blocks, result_disp, result_types, &
         temp_type, mpi_err)

    ! Adjust lower-bound and extent of type for tally score
    lower_bound = 0
    extent      = result_disp(1) + 16
    call MPI_TYPE_CREATE_RESIZED(temp_type, lower_bound, extent, &
         MPI_TALLYRESULT, mpi_err)

    ! Commit derived type for tally scores
    call MPI_TYPE_COMMIT(MPI_TALLYRESULT, mpi_err)

  end subroutine initialize_mpi
#endif

!===============================================================================
! READ_COMMAND_LINE reads all parameters from the command line
!===============================================================================

  subroutine read_command_line()

    integer :: i         ! loop index
    integer :: argc      ! number of command line arguments
    integer :: last_flag ! index of last flag
    character(MAX_FILE_LEN) :: pwd      ! present working directory
    character(MAX_WORD_LEN), allocatable :: argv(:) ! command line arguments

    ! Get working directory
    call GET_ENVIRONMENT_VARIABLE("PWD", pwd)

    ! Check number of command line arguments and allocate argv
    argc = COMMAND_ARGUMENT_COUNT()

    ! Allocate and retrieve command arguments
    allocate(argv(argc))
    do i = 1, argc
      call GET_COMMAND_ARGUMENT(i, argv(i))
    end do

    ! Process command arguments
    last_flag = 0
    i = 1
    do while (i <= argc)
      ! Check for flags
      if (starts_with(argv(i), "-")) then
        select case (argv(i))
        case ('-p', '-plot', '--plot')
          run_mode = MODE_PLOTTING
        case ('-n', '-n_particles', '--n_particles')
          ! Read number of particles per cycle
          i = i + 1
          n_particles = str_to_int(argv(i))

          ! Check that number specified was valid
          if (n_particles == ERROR_INT) then
            message = "Must specify integer after " // trim(argv(i-1)) // &
                 " command-line flag."
            call fatal_error()
          end if
        case ('-r', '-restart', '--restart')
          ! Read path for state point
          i = i + 1
          path_state_point = argv(i)
          restart_run = .true.

        case ('-t', '-tallies', '--tallies')
          run_mode = MODE_TALLIES

          ! Read path for state point
          i = i + 1
          path_state_point = argv(i)
          restart_run = .true.

        case ('-?', '-help', '--help')
          call print_usage()
          stop
        case ('-v', '-version', '--version')
          call print_version()
          stop
        case ('-eps_tol', '-ksp_gmres_restart')
          ! Handle options that would be based to PETSC
          i = i + 1
        case default
          message = "Unknown command line option: " // argv(i)
          call fatal_error()
        end select

        last_flag = i
      end if

      ! Increment counter
      i = i + 1
    end do

    ! Determine directory where XML input files are
    if (argc > 0 .and. last_flag < argc) then
      path_input = argv(last_flag + 1)
      ! Need to add working directory if the given path is a relative path
      if (.not. starts_with(path_input, "/")) then
        path_input = trim(pwd) // "/" // trim(path_input)
      end if
    else
      path_input = pwd
    end if

    ! Add slash at end of directory if it isn't there
    if (.not. ends_with(path_input, "/")) then
      path_input = trim(path_input) // "/"
    end if

    ! Free memory from argv
    deallocate(argv)

    ! TODO: Check that directory exists

  end subroutine read_command_line

!===============================================================================
! PREPARE_UNIVERSES allocates the universes array and determines the cells array
! for each universe.
!===============================================================================

  subroutine prepare_universes()

    integer              :: i                     ! index in cells array
    integer              :: i_univ                ! index in universes array
    integer              :: n_cells_in_univ       ! number of cells in a universe
    integer, allocatable :: index_cell_in_univ(:) ! the index in the univ%cells
                                                  ! array for each universe
    type(ElemKeyValueII), pointer :: pair_list => null()
    type(Universe),       pointer :: univ => null()
    type(Cell),           pointer :: c => null()

    allocate(universes(n_universes))

    ! We also need to allocate the cell count lists for each universe. The logic
    ! for this is a little more convoluted. In universe_dict, the (key,value)
    ! pairs are the id of the universe and the index in the array. In
    ! cells_in_univ_dict, it's the id of the universe and the number of cells.

    pair_list => universe_dict % keys()
    do while (associated(pair_list))
      ! find index of universe in universes array
      i_univ = pair_list % value
      univ => universes(i_univ)
      univ % id = pair_list % key

      ! check for lowest level universe
      if (univ % id == 0) BASE_UNIVERSE = i_univ

      ! find cell count for this universe
      n_cells_in_univ = cells_in_univ_dict % get_key(univ % id)

      ! allocate cell list for universe
      allocate(univ % cells(n_cells_in_univ))
      univ % n_cells = n_cells_in_univ

      ! move to next universe
      pair_list => pair_list % next
    end do

    ! Also allocate a list for keeping track of where cells have been assigned
    ! in each universe

    allocate(index_cell_in_univ(n_universes))
    index_cell_in_univ = 0

    do i = 1, n_cells
      c => cells(i)

      ! get pointer to corresponding universe
      i_univ = universe_dict % get_key(c % universe)
      univ => universes(i_univ)

      ! increment the index for the cells array within the Universe object and
      ! then store the index of the Cell object in that array
      index_cell_in_univ(i_univ) = index_cell_in_univ(i_univ) + 1
      univ % cells(index_cell_in_univ(i_univ)) = i
    end do

  end subroutine prepare_universes

!===============================================================================
! ADJUST_INDICES changes the values for 'surfaces' for each cell and the
! material index assigned to each to the indices in the surfaces and material
! array rather than the unique IDs assigned to each surface and material. Also
! assigns boundary conditions to surfaces based on those read into the bc_dict
! dictionary
!===============================================================================

  subroutine adjust_indices()

    integer :: i       ! index for various purposes
    integer :: j       ! index for various purposes
    integer :: k       ! loop index for lattices
    integer :: i_array ! index in surfaces/materials array 
    integer :: id      ! user-specified id
    type(Cell),        pointer :: c => null()
    type(Lattice),     pointer :: l => null()
    type(TallyObject), pointer :: t => null()

    do i = 1, n_cells
      ! =======================================================================
      ! ADJUST SURFACE LIST FOR EACH CELL

      c => cells(i)
      do j = 1, c % n_surfaces
        id = c % surfaces(j)
        if (id < OP_DIFFERENCE) then
          if (surface_dict % has_key(abs(id))) then
            i_array = surface_dict % get_key(abs(id))
            c % surfaces(j) = sign(i_array, id)
          else
            message = "Could not find surface " // trim(to_str(abs(id))) // &
                 " specified on cell " // trim(to_str(c % id))
            call fatal_error()
          end if
        end if
      end do

      ! =======================================================================
      ! ADJUST UNIVERSE INDEX FOR EACH CELL

      id = c % universe
      if (universe_dict % has_key(id)) then
        c % universe = universe_dict % get_key(id)
      else
        message = "Could not find universe " // trim(to_str(id)) // &
             " specified on cell " // trim(to_str(c % id))
        call fatal_error()
      end if

      ! =======================================================================
      ! ADJUST MATERIAL/FILL POINTERS FOR EACH CELL

      id = c % material
      if (id == MATERIAL_VOID) then
        c % type = CELL_NORMAL
      elseif (id /= 0) then
        if (material_dict % has_key(id)) then
          c % type = CELL_NORMAL
          c % material = material_dict % get_key(id)
        else
          message = "Could not find material " // trim(to_str(id)) // &
               " specified on cell " // trim(to_str(c % id))
          call fatal_error()
        end if
      else
        id = c % fill
        if (universe_dict % has_key(id)) then
          c % type = CELL_FILL
          c % fill = universe_dict % get_key(id)
        elseif (lattice_dict % has_key(id)) then
          c % type = CELL_LATTICE
          c % fill = lattice_dict % get_key(id)
        else
          message = "Specified fill " // trim(to_str(id)) // " on cell " // &
               trim(to_str(c % id)) // " is neither a universe nor a lattice."
          call fatal_error()
        end if
      end if
    end do

    ! ==========================================================================
    ! ADJUST UNIVERSE INDICES FOR EACH LATTICE

    do i = 1, n_lattices
      l => lattices(i)
      do j = 1, l % n_x
        do k = 1, l % n_y
          id = l % element(j,k)
          if (universe_dict % has_key(id)) then
            l % element(j,k) = universe_dict % get_key(id)
          else
            message = "Invalid universe number " // trim(to_str(id)) &
                 // " specified on lattice " // trim(to_str(l % id))
            call fatal_error()
          end if
        end do
      end do
    end do

    TALLY_LOOP: do i = 1, n_tallies
      t => tallies(i)

      ! =======================================================================
      ! ADJUST INDICES FOR EACH TALLY FILTER

      FILTER_LOOP: do j = 1, t % n_filters

        select case (t % filters(j) % type)
        case (FILTER_CELL, FILTER_CELLBORN)

          do k = 1, t % filters(j) % n_bins
            id = t % filters(j) % int_bins(k)
            if (cell_dict % has_key(id)) then
              t % filters(j) % int_bins(k) = cell_dict % get_key(id)
            else
              message = "Could not find cell " // trim(to_str(id)) // &
                   " specified on tally " // trim(to_str(t % id))
              call fatal_error()
            end if
          end do

        case (FILTER_SURFACE)

          do k = 1, t % filters(j) % n_bins
            id = t % filters(j) % int_bins(k)
            if (surface_dict % has_key(id)) then
              t % filters(j) % int_bins(k) = surface_dict % get_key(id)
            else
              message = "Could not find surface " // trim(to_str(id)) // &
                   " specified on tally " // trim(to_str(t % id))
              call fatal_error()
            end if
          end do

        case (FILTER_UNIVERSE)

          do k = 1, t % filters(j) % n_bins
            id = t % filters(j) % int_bins(k)
            if (universe_dict % has_key(id)) then
              t % filters(j) % int_bins(k) = universe_dict % get_key(id)
            else
              message = "Could not find universe " // trim(to_str(id)) // &
                   " specified on tally " // trim(to_str(t % id))
              call fatal_error()
            end if
          end do

        case (FILTER_MATERIAL)

          do k = 1, t % filters(j) % n_bins
            id = t % filters(j) % int_bins(k)
            if (material_dict % has_key(id)) then
              t % filters(j) % int_bins(k) = material_dict % get_key(id)
            else
              message = "Could not find material " // trim(to_str(id)) // &
                   " specified on tally " // trim(to_str(t % id))
              call fatal_error()
            end if
          end do

        case (FILTER_MESH)

          id = t % filters(j) % int_bins(1)
          if (mesh_dict % has_key(id)) then
            t % filters(j) % int_bins(1) = mesh_dict % get_key(id)
          else
            message = "Could not find mesh " // trim(to_str(id)) // &
                 " specified on tally " // trim(to_str(t % id))
            call fatal_error()
          end if

        end select

      end do FILTER_LOOP

    end do TALLY_LOOP

  end subroutine adjust_indices

!===============================================================================
! NORMALIZE_AO normalizes the atom or weight percentages for each material
!===============================================================================

  subroutine normalize_ao()

    integer        :: index_list      ! index in xs_listings array
    integer        :: i               ! index in materials array
    integer        :: j               ! index over nuclides in material
    real(8)        :: sum_percent     ! summation
    real(8)        :: awr             ! atomic weight ratio
    real(8)        :: x               ! atom percent
    logical        :: percent_in_atom ! nuclides specified in atom percent?
    logical        :: density_in_atom ! density specified in atom/b-cm?
    type(Material), pointer :: mat => null()

    ! first find the index in the xs_listings array for each nuclide in each
    ! material
    do i = 1, n_materials
      mat => materials(i)

      percent_in_atom = (mat % atom_density(1) > ZERO)
      density_in_atom = (mat % density > ZERO)

      sum_percent = ZERO
      do j = 1, mat % n_nuclides
        ! determine atomic weight ratio
        index_list = xs_listing_dict % get_key(mat % names(j))
        awr = xs_listings(index_list) % awr

        ! if given weight percent, convert all values so that they are divided
        ! by awr. thus, when a sum is done over the values, it's actually
        ! sum(w/awr)
        if (.not. percent_in_atom) then
          mat % atom_density(j) = -mat % atom_density(j) / awr
        end if
      end do

      ! determine normalized atom percents. if given atom percents, this is
      ! straightforward. if given weight percents, the value is w/awr and is
      ! divided by sum(w/awr)
      sum_percent = sum(mat % atom_density)
      mat % atom_density = mat % atom_density / sum_percent

      ! Change density in g/cm^3 to atom/b-cm. Since all values are now in atom
      ! percent, the sum needs to be re-evaluated as 1/sum(x*awr)
      if (.not. density_in_atom) then
        sum_percent = ZERO
        do j = 1, mat % n_nuclides
          index_list = xs_listing_dict % get_key(mat % names(j))
          awr = xs_listings(index_list) % awr
          x = mat % atom_density(j)
          sum_percent = sum_percent + x*awr
        end do
        sum_percent = ONE / sum_percent
        mat % density = -mat % density * N_AVOGADRO & 
             / MASS_NEUTRON * sum_percent
      end if

      ! Calculate nuclide atom densities
      mat % atom_density = mat % density * mat % atom_density
    end do

  end subroutine normalize_ao

!===============================================================================
! CALCULATE_WORK determines how many particles each processor should simulate
!===============================================================================

  subroutine calculate_work()

    ! Determine maximum amount of particles to simulate on each processor
    maxwork = ceiling(real(n_particles)/n_procs,8)

    ! ID's of first and last source particles
    bank_first = rank*maxwork + 1
    bank_last  = min((rank+1)*maxwork, n_particles)

    ! number of particles for this processor
    work = bank_last - bank_first + 1

  end subroutine calculate_work

!===============================================================================
! ALLOCATE_BANKS allocates memory for the fission and source banks
!===============================================================================

  subroutine allocate_banks()

    integer    :: alloc_err  ! allocation error code

    ! Allocate source bank
    allocate(source_bank(maxwork), STAT=alloc_err)

    ! Check for allocation errors 
    if (alloc_err /= 0) then
      message = "Failed to allocate source bank."
      call fatal_error()
    end if

    ! Allocate fission bank
    allocate(fission_bank(3*maxwork), STAT=alloc_err)

    ! Check for allocation errors 
    if (alloc_err /= 0) then
      message = "Failed to allocate fission bank."
      call fatal_error()
    end if

  end subroutine allocate_banks

end module initialize
