module ndpp_ops

  use ace_header,   only: XsListing
  use constants
  use dict_header,  only: DictCharInt, DICT_NULL
  use error,        only: fatal_error
  use global
  use list_header,  only: ListElemInt
  use math,         only: calc_rn
  use ndpp_header,  only: GrpTransfer, Ndpp
  use search
  use string,       only: ends_with, to_lower, starts_with, to_str
  use tally_header, only: TallyResult
  use xml_interface

  implicit none

  contains

!===============================================================================
! NDPP_READ reads information from a pre-processed nuclear data file
! as generated by the NDPP program and initializes the Ndpp object accordingly.
!===============================================================================

  subroutine ndpp_read(this, listing, get_scatt, get_nuscatt, get_chi_t, get_chi_p, &
                       get_chi_d, scatt_order, is_nuc)
    type(Ndpp), intent(inout) :: this ! Ndpp object to initialize
    type(XsListing),  pointer, intent(in) :: listing ! Current NDPP data file
    logical, intent(in) :: get_scatt   ! Whether or not to get scatt data
    logical, intent(in) :: get_nuscatt ! Whether or not to get nuscatt data
    logical, intent(in) :: get_chi_t   ! Whether or not to get total chi data
    logical, intent(in) :: get_chi_p   ! Whether or not to get prompt chi data
    logical, intent(in) :: get_chi_d   ! Whether or not to get delayed chi data
    integer, intent(in) :: scatt_order ! Number of moments requested in tallies
    logical, intent(in) :: is_nuc      ! Is our data a nuc or an sab?

    integer       :: in = 7        ! file unit
    integer       :: i             ! loop index for data records
    integer       :: location      ! location of NDPP table
    integer       :: filetype      ! Ascii, Binary or HDF5 filetype
    logical       :: file_exists   ! does NDPP library exist?
    character(7)  :: readable      ! is NDPP library readable?
    character(10) :: name          ! name of NDPP table
    real(8)       :: kT            ! temperature of table
    real(8)       :: dkT           ! difference in temperature of table
    integer       :: NG            ! Number of energy groups in library
    character(MAX_FILE_LEN) :: filename ! path to NDPP data library
    real(8), allocatable    :: energy_bins(:) ! Energy group structure
    integer       :: mu_bins       ! NUmber of angular points used
    integer       :: scatt_type    ! Type of scattering data, discarded
    integer       :: lib_order     ! Order of scattering data in library
    integer       :: nuscatter     ! Flag as to if nuscatter data is present
    integer       :: chi_present   ! Flag as to if chi data is present
    integer       :: gmin, gmax    ! Min and max possible group transfers
    integer       :: g             ! Group index
    real(8)       :: thin_tol      ! Thinning tolerance used in lib, discarded
    integer       :: NEin, iE      ! Number of incoming energies and the index
    real(8), allocatable :: temp_outgoing(:,:) ! Temporary storage of scatt data
    integer       :: NP            ! Number of precursors groups

    ! determine path, record length, and location of table
    filename      = listing % path
    filetype      = listing % filetype
    location      = listing % location

    ! Check if ACE library exists and is readable
    inquire(FILE=filename, EXIST=file_exists, READ=readable)
    if (.not. file_exists) then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' does not exist!")
    elseif (readable(1:3) == 'NO') then
      call fatal_error("NDPP library '" // trim(filename) // &
           "' is not readable! Change file permissions with chmod command.")
    end if

    if (listing % filetype == ASCII) then
      ! =======================================================================
      ! READ NDPP DATA IN ASCII FORMAT

      ! Find location of table
      open(UNIT=in, FILE=filename, STATUS='old', ACTION='read')
      rewind(UNIT=in)
      do i = 1, location - 1
        read(UNIT=in, FMT=*)
      end do

      ! Read the header information to make sure this is the correct file
      read(UNIT=in, FMT='(A20,1PE20.12,I20,A20)') name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set)
      allocate(energy_bins(NG + 1))
      read(UNIT=in, FMT=*) energy_bins
      ! The next line is scatt_type, lib_order, nuscatter, chi_present
      read(UNIT=in, FMT='(I20,I20,I20,I20)') scatt_type, lib_order, &
        nuscatter, chi_present
      ! Finally, mu_bins, thin_tol
      read(UNIT=in, FMT='(I20,1PE20.12)') mu_bins, thin_tol

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Start with elastic data
      ! Get Ein information

      ! First find our data length
      read(UNIT=in, FMT='(I20)') NEin
      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in, FMT=*) this % el_Ein
      read(UNIT=in, FMT=*) this % el_Ein_srch

      ! Get the elastic moments themselves
      do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in, FMT='(I20,I20)') gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in, FMT=*) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
            temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do

      ! The remainder only apply to nuclides (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in, FMT='(I20)') NEin
        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in, FMT=*) this % inel_Ein
          read(UNIT=in, FMT=*) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in, FMT='(I20,I20)') gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to have
              ! an array for reading the file which we can later truncate to fit
              ! in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in, FMT=*) temp_outgoing
              ! And copy in to this % el
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in, FMT='(I20,I20)') gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, we also need to have
                ! an array for reading the file which we can later truncate to fit
                ! in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in, FMT=*) temp_outgoing
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                  gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                  temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do
          end if
        end if

        ! Get chi(E_{in}) data if provided
        if (chi_present == 1) then
          ! Get Ein grid and number of precursors
          read(UNIT=in, FMT='(I20,I20)') NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in, FMT=*) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in, FMT=*) this % chi

          ! Get Chi-Prompt
          read(UNIT=in, FMT=*) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in, FMT=*) this % chi_d
        end if
      end if

      close(UNIT=in)

    else if (listing % filetype == BINARY) then
      ! =======================================================================
      ! READ NDPP DATA IN BINARY FORMAT

      ! Open file
      open(UNIT=in, FILE=filename, STATUS='old', ACTION='read', ACCESS='stream')
      rewind(UNIT=in)
      ! right now binary files dont have the capability to do location /= 1!

      ! Read the header information to make sure this is the correct file
      read(UNIT=in) name, kT, NG
      dkT = abs(kT - listing % kT) / kT
      if ((adjustl(trim(name)) /= listing % name) .or. (dkT > 0.001_8)) then
        call fatal_error("NDPP library '" // trim(filename) // &
             "' does not contain the correct data set where expected!")
      end if
      ! Get the energy bins (not checking, will assume from here on out we have
      ! the right data set), and the other meta information
      allocate(energy_bins(NG + 1))
      read(UNIT=in) energy_bins, scatt_type, lib_order, &
        nuscatter, chi_present, mu_bins, thin_tol

      ! set lib_order to the right number for allocating the outgoing array
      if (scatt_type == SCATT_TYPE_LEGENDRE) lib_order = lib_order + 1

      ! Get \sigma_{s,g'->g,l}(E_{in}) data
      ! Get elastic Ein information

      ! First find our data length, doesnt depend on nuc or sab
      read(UNIT=in) NEin

      ! Now allocate all that will be filled
      allocate(this % el_Ein(NEin))
      allocate(this % el_Ein_srch(NG + 1))
      allocate(this % el(NEin))

      ! Now read in el_Ein and el_Ein_srch
      read(UNIT=in) this % el_Ein
      read(UNIT=in) this % el_Ein_srch

      ! Now we can get the elastic moments themselves one-by-one due to sparse
      ! storage nature.
      do iE = 1, NEin
        ! get gmin and gmax
        read(UNIT=in) gmin, gmax

        if ((gmin > 0) .and. (gmax > 0)) then
          ! Then we can allocate the space. Do it to lib_order
          ! since this is the largest order requested in the tallies.
          ! Since we only need to store up to the maximum, we also need to have
          ! an array for reading the file which we can later truncate to fit
          ! in to this % el(iE) % outgoing.
          allocate(temp_outgoing(lib_order, gmin : gmax))

          ! Now we have a space to store the data, get it.
          read(UNIT=in) temp_outgoing
          ! And copy in to this % el
          allocate(this % el(iE) % outgoing(scatt_order, gmin : gmax))
          this % el(iE) % outgoing(:, gmin : gmax) = &
            temp_outgoing(1 : scatt_order, gmin : gmax)
          deallocate(temp_outgoing)
        end if
      end do

      ! The remainder only apply to nuclides (inelastic, nu-inelastic and chi data)
      if (is_nuc) then
        read(UNIT=in) NEin
        if (NEin > 0) then
          ! Now allocate all that will be filled
          allocate(this % inel_Ein(NEin))
          allocate(this % inel_Ein_srch(NG + 1))
          allocate(this % inel(NEin))

          ! Now read in inel_Ein, inel_Ein_srch
          read(UNIT=in) this % inel_Ein
          read(UNIT=in) this % inel_Ein_srch

          ! Get the inelastic moments themselves
          do iE = 1, NEin
            ! get gmin and gmax
            read(UNIT=in) gmin, gmax

            if ((gmin > 0) .and. (gmax > 0)) then
              ! Then we can allocate the space. Do it to lib_order
              ! since this is the largest order requested in the tallies.
              ! Since we only need to store up to the maximum, we also need to have
              ! an array for reading the file which we can later truncate to fit
              ! in to this % inel(iE) % outgoing.
              allocate(temp_outgoing(lib_order, gmin : gmax))

              ! Now we have a space to store the data, get it.
              read(UNIT=in) temp_outgoing
              ! And copy in to this % inel
              allocate(this % inel(iE) % outgoing(scatt_order, gmin : gmax))
              this % inel(iE) % outgoing(:, gmin : gmax) = &
                temp_outgoing(1 : scatt_order, gmin : gmax)
              deallocate(temp_outgoing)
            end if
          end do

          ! Get nu-scatter, if needed
          if (nuscatter == 1) then
            allocate(this % nuinel(NEin))
            do iE = 1, NEin
              ! get gmin and gmax
              read(UNIT=in) gmin, gmax

              if ((gmin > 0) .and. (gmax > 0)) then
                ! Then we can allocate the space. Do it to lib_order
                ! since this is the largest order requested in the tallies.
                ! Since we only need to store up to the maximum, we also need to have
                ! an array for reading the file which we can later truncate to fit
                ! in to this % nuinel(iE) % outgoing.
                allocate(temp_outgoing(lib_order, gmin : gmax))

                ! Now we have a space to store the data, get it.
                read(UNIT=in) temp_outgoing
                ! And copy in to this % nuinel
                allocate(this % nuinel(iE) % outgoing(scatt_order, &
                  gmin : gmax))
                this % nuinel(iE) % outgoing(:, gmin : gmax) = &
                  temp_outgoing(1 : scatt_order, gmin : gmax)
                deallocate(temp_outgoing)
              end if
            end do
          end if
        end if

        ! Get chi data, if provided
        if (chi_present == 1) then
          ! Get Ein grid and Number of Precursors
          read(UNIT=in) NEin, NP

          ! Allocate data as needed
          allocate(this % chi_Ein(NEin))
          allocate(this % chi(size(energy_bins) - 1, NEin))
          allocate(this % chi_p(size(energy_bins) - 1, NEin))
          allocate(this % chi_d(size(energy_bins) - 1, NP, NEin))

          ! Get Ein Grid
          read(UNIT=in) this % chi_Ein

          ! Get Chi-Total
          read(UNIT=in) this % chi

          ! Get Chi-Prompt
          read(UNIT=in) this % chi_p

          ! Get Chi-Delayed
          read(UNIT=in) this % chi_p
        end if
      end if

      close(UNIT=in)

    else if (listing % filetype == H5) then
      ! =======================================================================
      ! READ NDPP DATA IN HDF5 FORMAT

      ! NOT YET IMPLEMENTED

    end if ! No default needed - read_ndpp_xml() already checked filetype

    ! Finally, the above code read in all data since NDPP libs are sequential
    ! access; now we can deallocate what we do not need
    if (is_nuc) then
      if (.not. get_scatt) then
        if (associated(this % inel)) then
          deallocate(this % inel)
        end if
      end if
      if (.not. get_nuscatt) then
        if (associated(this % nuinel)) then
          deallocate(this % nuinel)
        end if
      end if
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (associated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (associated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
        if (associated(this % inel_Ein)) then
          deallocate(this % inel_Ein)
        end if
        if (associated(this % inel_Ein_srch)) then
          deallocate(this % inel_Ein_srch)
        end if
      end if
      if (.not. get_chi_t) then
        if (associated(this % chi)) then
          deallocate(this % chi)
        end if
      end if
      if (.not. get_chi_p) then
        if (associated(this % chi_p)) then
          deallocate(this % chi_p)
        end if
      end if
      if (.not. get_chi_d) then
        if (associated(this % chi_d)) then
          deallocate(this % chi_d)
        end if
      end if
      if ((.not. get_chi_t) .and. (.not. get_chi_p) .and. (.not. get_chi_d)) then
        if (associated(this % chi_Ein)) then
          deallocate(this % chi_Ein)
        end if
      end if
    else ! Do similar for S(a,b) tables, dont need to check inel here
      if ((.not. get_scatt) .and. (.not. get_nuscatt)) then
        if (associated(this % el)) then
          deallocate(this % el)
        end if
        if (associated(this % el_Ein)) then
          deallocate(this % el_Ein)
        end if
        if (associated(this % el_Ein_srch)) then
          deallocate(this % el_Ein_srch)
        end if
      end if
    end if

    this % is_nuc = is_nuc
    this % is_init = .True.
    this % zaid = listing % zaid
    this % kT = listing % kT

  end subroutine ndpp_read

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_N determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-n tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_n(this, i_nuclide, gin, score_index, &
                                filter_index, t_order, mult, is_analog, Ein, &
                                results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: l         ! tally order index to score
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s

    l = t_order + 1

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(Ein, i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_n(this, gin, l, Ein, sigs_el, sigs_inel, &
                                  norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the contribution from the elastic score
    do g = gmin, gmax
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        ndpp_outgoing(thread_id, l, g) * norm
    end do
  end subroutine ndpp_tally_scatt_n

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_PN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-pn tally types (including nu-scatter)
!===============================================================================

  subroutine ndpp_tally_scatt_pn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(Ein, i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, gin, t_order, Ein, sigs_el, sigs_inel, &
                                  norm, gmin, gmax)

    ! Apply mult to the normalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      do l = 1, t_order + 1
        i_score = score_index + l - 1
!$omp atomic
        results(i_score, g_filter) % value = &
          results(i_score, g_filter) % value + ndpp_outgoing(thread_id, l, g) * norm
      end do
    end do
  end subroutine ndpp_tally_scatt_pn

!===============================================================================
! NDPP_TALLY_NDPP_SCATT_YN determines the scattering moments which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-yn tally types (including nu-scatter)
! which incorporate the angular flux moments.
!===============================================================================

  subroutine ndpp_tally_scatt_yn(this, i_nuclide, gin, score_index, &
                                 filter_index, t_order, mult, is_analog, Ein, &
                                 uvw, results, nuscatt)
    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: gin          ! Incoming group index
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    integer, intent(in) :: t_order      ! # of scattering orders to tally
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    real(8), intent(in) :: uvw(3)       ! direction coordinates
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage
    logical, optional, intent(in) :: nuscatt         ! Is this for nuscatter?

    integer :: g         ! outgoing energy group index
    integer :: g_filter  ! outgoing energy group index
    integer :: i_score   ! index of score dimension of results
    integer :: l         ! legendre moment index
    real(8) :: norm      ! Interpolation constant, multiplied by sigS (if in TL)
    integer :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer :: gmax      ! Maximum group transfer in ndpp_outgoing
    integer :: num_lm    ! Number of m for this l
    real(8) :: sigs_el   ! Elastic x/s
    real(8) :: sigs_inel ! Inelastic x/s

    ! First we need to calculate the x/s to use when creating our distribution.
    call calc_scatter_xs(Ein, i_nuclide, sigs_el, sigs_inel)

    ! Now combine the elastic and inelastic distributions to one set,
    ! which will be in ndpp_outgoing(thread_id,:,:)
    call generate_ndpp_distrib_pn(this, gin, t_order, Ein, sigs_el, sigs_inel, &
                                  norm, gmin, gmax)

    ! Apply mult to the n ormalization constant, norm
    norm = norm * mult
    ! Now apply sigS if we are in tracklength mode
    if (.not. is_analog) then
      norm = norm * (micro_xs(i_nuclide) % total - &
        micro_xs(i_nuclide) % absorption)
    end if

    ! Add the combined distribution to our tally for each order
    do g = gmin, gmax
      g_filter = filter_index + g - 1
      i_score = score_index
      do l = 0, t_order
        num_lm = 2 * l + 1
!$omp critical
        results(i_score: i_score + num_lm - 1, g_filter) % value = &
          results(i_score: i_score + num_lm - 1, g_filter) % value + &
          ndpp_outgoing(thread_id, l + 1, g) * norm * calc_rn(l, uvw)
!$omp end critical

        i_score = i_score + num_lm
      end do
    end do
  end subroutine ndpp_tally_scatt_yn

!===============================================================================
! TALLY_NDPP_CHI determines the fission spectra which were
! previously calculated with a pre-processor such as NDPP;
! this can be used for analog and tracklength estimators;
! this method applies to ndpp-scatter-chi tally types
!===============================================================================

  subroutine ndpp_tally_chi(this, i_nuclide, score_index, filter_index, mult, &
                            is_analog, Ein, score_type, results)

    type(Ndpp), intent(in) :: this      ! Ndpp object to act on
    integer, intent(in) :: i_nuclide    ! index into nuclides array
    integer, intent(in) :: score_index  ! dim = 1 starting index in results
    integer, intent(in) :: filter_index ! dim = 2 starting index (incoming E filter)
    real(8), intent(in) :: mult         ! wgt or wgt * atom_density * flux
    logical, intent(in) :: is_analog    ! Is this an analog or TL event?
    real(8), intent(in) :: Ein          ! Incoming energy
    integer, intent(in) :: score_type   ! Type of Chi score we are using
    type(TallyResult), intent(inout) :: results(:,:) ! Tally results storage

    integer :: g                         ! outgoing energy group index
    integer :: g_filter                  ! outgoing energy group index
    integer :: i_grid                    ! index on nuclide energy grid
    real(8) :: f                         ! interp factor on nuclide energy grid
    real(8) :: one_f                     ! (ONE - f)
    real(8), pointer, save :: chi_Ein(:) ! Working Ein grid
    real(8), pointer, save :: chi(:,:)   ! Working chi data

!$omp threadprivate(chi_Ein, chi)

    ! Set up pointers
    chi_Ein => this % chi_Ein
    if (score_type == SCORE_NDPP_CHI) then
      chi => this % chi
    else if (score_type == SCORE_NDPP_CHI_P) then
      chi => this % chi_p
    else if (score_type == SCORE_NDPP_CHI_D) then
      call fatal_error("OpenMC does not yet support Delayed Chi Tallying!")
      !chi => this % chi_d
    end if

    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= chi_Ein(1)) then
      i_grid = 1
      f = ZERO
    else if (Ein >= chi_Ein(size(chi_Ein))) then
      ! Should never happen as max(ndpp_Ein) is above filter range
      return
    else
      i_grid = binary_search(chi_Ein, size(chi_Ein), Ein)
      f = (Ein - chi_Ein(i_grid)) / &
        (chi_Ein(i_grid + 1) - chi_Ein(i_grid))
    end if

    ! Calculate 1-f, apply mult, and weight by nu-fission for TL
    one_f = (ONE - f) * mult
    f = f * mult
    ! Weight only by nu for analog since the collision estimator process already
    ! is effectively sampling the fission xs
    if (.not. is_analog) then
      f = f * micro_xs(i_nuclide) % nu_fission
      one_f = one_f * micro_xs(i_nuclide) % nu_fission
    end if

    ! Add the contribution from NDPP data (with interpolation)
    do g = 1, ubound(chi, dim=1)
      g_filter = filter_index + g - 1
!$omp atomic
      results(score_index, g_filter) % value = &
        results(score_index, g_filter) % value + &
        chi(g, i_grid) * one_f + &
        chi(g, i_grid + 1) * f
    end do

  end subroutine ndpp_tally_chi

!===============================================================================
! HELPER SUBROUTINES
!===============================================================================

!===============================================================================
! CALC_SCATTER_XS Find the elastic and total inelastic cross-sections at the
! given energy Ein for the nuclide denoted by i_nuclide.
!===============================================================================

  subroutine calc_scatter_xs(Ein, i_nuclide, sigs_el, sigs_inel)
    real(8), intent(in)  :: Ein       ! Incoming energy
    integer, intent(in)  :: i_nuclide ! index into nuclides array
    real(8), intent(out) :: sigs_el   ! Elastic x/s
    real(8), intent(out) :: sigs_inel ! Inelastic x/s

    if (micro_xs(i_nuclide) % use_ptable) then
      ! We have to get the non-URR elastic x/s which is the average value
      sigs_el = (ONE - micro_xs(i_nuclide) % interp_factor) * &
        nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid) &
        + micro_xs(i_nuclide) % interp_factor * &
        nuclides(i_nuclide) % elastic(micro_xs(i_nuclide) % index_grid + 1)
      ! First get the total scattering x/s
      sigs_inel = (ONE - micro_xs(i_nuclide) % interp_factor) * &
        (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid) - &
         nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid)) + &
        (micro_xs(i_nuclide) % interp_factor) * &
        (nuclides(i_nuclide) % total(micro_xs(i_nuclide) % index_grid + 1) - &
         nuclides(i_nuclide) % absorption(micro_xs(i_nuclide) % index_grid + 1))
      ! Now take away elastic to get the total inelastic
      sigs_inel = sigs_inel - sigs_el
    else
      sigs_el   = micro_xs(i_nuclide) % elastic
      sigs_inel = micro_xs(i_nuclide) % total - micro_xs(i_nuclide) % absorption - &
        sigs_el
    end if

  end subroutine calc_scatter_xs


!===============================================================================
! FIND_NDPP_INDICES determines the group boundaries of relevant data in both
! the elastic and inelastic NDPP data sets (as passed to it by the el_* and
! inel_*) data.  Since the data is readily available, it also finds the
! interpolation factors el_f and inel_f.
!===============================================================================

  subroutine find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                               inel_gmin, inel_gmax, gmin, gmax, &
                               el_igrid, inel_igrid, el_f, inel_f)
    type(Ndpp), intent(in) :: this       ! Ndpp data to use
    integer, intent(in)    :: gin        ! Incoming group index
    real(8), intent(in)    :: Ein        ! Incoming energy
    integer, intent(out)   :: el_gmin    ! Elastic min outgoing group
    integer, intent(out)   :: el_gmax    ! Elastic max outgoing group
    integer, intent(out)   :: inel_gmin  ! Inelastic min outgoing group
    integer, intent(out)   :: inel_gmax  ! Inelastic max outgoing group
    integer, intent(out)   :: gmin       ! Min outgoing group for both el and inel
    integer, intent(out)   :: gmax       ! Max outgoing group for both el and inel
    real(8), intent(out)   :: el_f       ! Elastic interpolant
    real(8), intent(out)   :: inel_f     ! Inelastic interpolant
    integer, intent(out)   :: el_igrid   ! Elastic data location
    integer, intent(out)   :: inel_igrid ! Inelastic data location

    integer :: srch_lo, srch_hi

    inel_gmin = huge(0)
    inel_gmax = 0

    ! Create distribution for elastic scattering
    ! First perform the binary search to find where our Ein point is
    srch_lo = this % el_Ein_srch(gin)
    srch_hi = this % el_Ein_srch(gin + 1)
    ! Find the grid index and interpolant of ndpp scattering data
    if (Ein <= this % el_Ein(1)) then
      el_igrid = 1
      el_f = ZERO
    else if (Ein >= this % el_Ein(size(this % el_Ein))) then
      el_igrid = size(this % el_Ein) - 1
      el_f = ONE
    else
      el_igrid = binary_search(this % el_Ein(srch_lo: srch_hi), &
                             srch_hi - srch_lo + 1, Ein) + srch_lo - 1
      el_f = log(Ein / this % el_Ein(el_igrid)) / &
        log(this % el_Ein(el_igrid + 1) / this % el_Ein(el_igrid))
    end if

    ! Now find our gmin and gmax terms
    el_gmin = min(lbound(this % el(el_igrid) % outgoing, dim=2), &
                  lbound(this % el(el_igrid + 1) % outgoing, dim=2))
    el_gmax = max(ubound(this % el(el_igrid) % outgoing, dim=2), &
                  ubound(this % el(el_igrid + 1) % outgoing, dim=2))

    ! Now do the same for inelastic, if it is necessary (i.e., if not s(a,b))
    ! We can tell if we are s(a,b) because then the inel* pointers will be null
    if (associated(this % inel)) then
      if (Ein <= this % inel_Ein(1)) then
        ! Then our point is below the threshold: break this conditional
        ! without changing inel_gmin and inel_gmax
        gmin = el_gmin
        gmax = el_gmax
        if (gmin == huge(0)) then
          gmin = 0
          gmax = -1
        end if
      else
        ! Perform same steps as above, but with inelastic.
        ! Also, we will get our normalization constants from the NDPP data itself.
        ! First perform the binary search to find where our incoming E points is
        srch_lo = this % inel_Ein_srch(gin)
        srch_hi = this % inel_Ein_srch(gin + 1)
        ! Find the grid index and interpolant of ndpp scattering data
        if (Ein >= this % inel_Ein(size(this % inel_Ein))) then
          inel_igrid = size(this % inel_Ein) - 1
          inel_f = ONE
        else
          inel_igrid = binary_search(this % inel_Ein(srch_lo: srch_hi), &
                                 srch_hi - srch_lo + 1, Ein) + srch_lo - 1
          inel_f = log(Ein / this % inel_Ein(inel_igrid)) / &
            log(this % inel_Ein(inel_igrid + 1) / this % inel_Ein(inel_igrid))
        end if

        ! Now find our gmin and gmax terms
        if ((allocated(this % inel(inel_igrid) % outgoing)) .and. &
            (allocated(this % inel(inel_igrid + 1) % outgoing))) then
          inel_gmin = min(lbound(this % inel(inel_igrid) % outgoing, dim=2), &
                        lbound(this % inel(inel_igrid + 1) % outgoing, dim=2))
          inel_gmax = max(ubound(this % inel(inel_igrid) % outgoing, dim=2), &
                        ubound(this % inel(inel_igrid + 1) % outgoing, dim=2))
        else if (allocated(this % inel(inel_igrid) % outgoing)) then
          inel_gmin = lbound(this % inel(inel_igrid) % outgoing, dim=2)
          inel_gmax = ubound(this % inel(inel_igrid) % outgoing, dim=2)
        else if (allocated(this % inel(inel_igrid + 1) % outgoing)) then
          inel_gmin = lbound(this % inel(inel_igrid+1) % outgoing, dim=2)
          inel_gmax = ubound(this % inel(inel_igrid+1) % outgoing, dim=2)
        end if

        ! Set our group boundaries
        gmin = min(el_gmin, inel_gmin)
        gmax = max(el_gmax, inel_gmax)
      end if
    else
      ! Set our other outgoing data
      gmin = el_gmin
      gmax = el_gmax
    end if

    ! Fix up gmin and gmax if need be
    if (gmin == huge(0)) then
      gmin = 0
      gmax = -1
    end if

  end subroutine find_ndpp_indices

!===============================================================================
! GENERATE_NDPP_DISTRIB_N combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_N version of
! this function provides this capability for score-ndpp-*scatter-n tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_n(this, gin, l, Ein, sigs_el, sigs_inel, &
                                     norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, l, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = el_one_f * &
          this % el(el_igrid) % outgoing(l, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, l, g) = &
          ndpp_outgoing(thread_id, l, g) + &
          el_f * this % el(el_igrid + 1) % outgoing(l, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(this % inel(inel_igrid) % outgoing)) then
        do g = lbound(this % inel(inel_igrid) % outgoing, dim=2), &
               ubound(this % inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
            this % inel(inel_igrid) % outgoing(l, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(this % inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(this % inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(this % inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, l, g) = ndpp_outgoing(thread_id, l, g) + &
            this % inel(inel_igrid + 1) % outgoing(l, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_n

!===============================================================================
! GENERATE_NDPP_DISTRIB_PN combines the elastic and inelastic portions of the
! NDPP scattering data such that a single number can be readily tallied.
! This includes performing all the interpolation necessary.  The *_PN version of
! this function provides this capability for score-ndpp-*scatter-pn tallies only.
!===============================================================================

  subroutine generate_ndpp_distrib_pn(this, gin, l, Ein, sigs_el, sigs_inel, &
                                      norm, gmin, gmax)
    type(Ndpp), intent(in) :: this      ! Ndpp data to use
    integer, intent(in)    :: gin       ! Incoming group index
    integer, intent(in)    :: l         ! Legendre order to score up to
    real(8), intent(in)    :: Ein       ! Incoming energy
    real(8), intent(in)    :: sigs_el   ! Elastic x/s
    real(8), intent(in)    :: sigs_inel ! Inelastic x/s
    real(8), intent(inout) :: norm      ! Total normalization
    integer, intent(inout) :: gmin      ! Minimum group transfer in ndpp_outgoing
    integer, intent(inout) :: gmax      ! Maximum group transfer in ndpp_outgoing

    integer :: el_igrid, inel_igrid
    integer :: el_gmin, el_gmax, inel_gmin, inel_gmax, g
    real(8) :: el_f, el_one_f, inel_f, inel_one_f

    ! Find where our data is
    call find_ndpp_indices(this, gin, Ein, el_gmin, el_gmax, &
                           inel_gmin, inel_gmax, gmin, gmax, &
                           el_igrid, inel_igrid, el_f, inel_f)

    ! Create our 1-interpolants based on the newly found *el_f values
    el_one_f   = ONE - el_f
    inel_one_f = ONE - inel_f
    norm = ONE / (sigs_el + sigs_inel)

    ! Set up our distribution storage so we can add the components up
    ndpp_outgoing(thread_id, 1: l + 1, gmin: gmax) = ZERO

    ! Now we can interpolate on the elastic data and put it in ndpp_outgoing
    ! Do lower point
    if (allocated(this % el(el_igrid) % outgoing)) then
      el_one_f = el_one_f * sigs_el
      do g = lbound(this % el(el_igrid) % outgoing, dim=2), &
             ubound(this % el(el_igrid) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = el_one_f * &
          this % el(el_igrid) % outgoing(1: l + 1, g)
      end do
    end if
    ! Do upper point
    if (allocated(this % el(el_igrid + 1) % outgoing)) then
      el_f = el_f * sigs_el
      do g = lbound(this % el(el_igrid + 1) % outgoing, dim=2), &
             ubound(this % el(el_igrid + 1) % outgoing, dim=2)
        ndpp_outgoing(thread_id, 1: l + 1, g) = &
          ndpp_outgoing(thread_id, 1: l + 1, g) + &
          el_f * this % el(el_igrid + 1) % outgoing(1: l + 1, g)
      end do
    end if

    ! And do the same for inelastic, if necessary
    if (inel_gmin /= huge(0)) then
      ! Do lower point
      if (allocated(this % inel(inel_igrid) % outgoing)) then
        do g = lbound(this % inel(inel_igrid) % outgoing, dim=2), &
               ubound(this % inel(inel_igrid) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
            ndpp_outgoing(thread_id, 1: l + 1, g) + &
            this % inel(inel_igrid) % outgoing(1: l + 1, g) * inel_one_f
        end do
      end if
      ! Do upper point
      if (allocated(this % inel(inel_igrid + 1) % outgoing)) then
        do g = lbound(this % inel(inel_igrid + 1) % outgoing, dim=2), &
               ubound(this % inel(inel_igrid + 1) % outgoing, dim=2)
          ndpp_outgoing(thread_id, 1: l + 1, g) = &
            ndpp_outgoing(thread_id, 1: l + 1, g) + &
            this % inel(inel_igrid + 1) % outgoing(1: l + 1, g) * inel_f
        end do
      end if
    end if

  end subroutine generate_ndpp_distrib_pn

end module ndpp_ops
