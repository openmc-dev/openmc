module simple_string

  use constants, only: ERROR_REAL, ERROR_INT, MAX_LINE_LEN

  implicit none

  interface to_str
    module procedure int4_to_str, int8_to_str, real_to_str
  end interface

contains

!===============================================================================
! TO_LOWER converts a string to all lower case characters
!===============================================================================

  pure function to_lower(word) result(word_lower)
    character(*), intent(in) :: word
    character(len=len(word)) :: word_lower

    integer :: i
    integer :: ic

    do i = 1, len(word)
      ic = ichar(word(i:i))
      if (ic >= 65 .and. ic <= 90) then
        word_lower(i:i) = char(ic+32)
      else
        word_lower(i:i) = word(i:i)
      end if
    end do

  end function to_lower

!===============================================================================
! TO_UPPER converts a string to all upper case characters
!===============================================================================

  pure function to_upper(word) result(word_upper)
    character(*), intent(in) :: word
    character(len=len(word)) :: word_upper

    integer :: i
    integer :: ic

    do i = 1, len(word)
      ic = ichar(word(i:i))
      if (ic >= 97 .and. ic <= 122) then
        word_upper(i:i) = char(ic-32)
      else
        word_upper(i:i) = word(i:i)
      end if
    end do

  end function to_upper

!===============================================================================
! IS_NUMBER determines whether a string of characters is all 0-9 characters
!===============================================================================

  pure function is_number(word) result(number)
    character(*), intent(in) :: word
    logical                  :: number

    integer :: i
    integer :: ic

    number = .true.
    do i = 1, len_trim(word)
      ic = ichar(word(i:i))
      if (ic < 48 .or. ic >= 58) number = .false.
    end do

  end function is_number

!===============================================================================
! STARTS_WITH determines whether a string starts with a certain
! sequence of characters
!===============================================================================

  pure logical function starts_with(str, seq)
    character(*), intent(in) :: str ! string to check
    character(*), intent(in) :: seq ! sequence of characters

    integer :: i
    integer :: i_start
    integer :: str_len
    integer :: seq_len

    str_len = len_trim(str)
    seq_len = len_trim(seq)

    ! determine how many spaces are at beginning of string
    i_start = 0
    do i = 1, str_len
      if (str(i:i) == ' ' .or. str(i:i) == achar(9)) cycle
      i_start = i
      exit
    end do

    ! Check if string starts with sequence using INDEX intrinsic
    if (index(str(1:str_len), seq(1:seq_len)) == i_start) then
      starts_with = .true.
    else
      starts_with = .false.
    end if

  end function starts_with

!===============================================================================
! ENDS_WITH determines whether a string ends with a certain sequence
! of characters
!===============================================================================

  pure logical function ends_with(str, seq)
    character(*), intent(in) :: str ! string to check
    character(*), intent(in) :: seq ! sequence of characters

    integer :: i_start
    integer :: str_len
    integer :: seq_len

    str_len = len_trim(str)
    seq_len = len_trim(seq)

    ! determine how many spaces are at beginning of string
    i_start = str_len - seq_len + 1

    ! Check if string starts with sequence using INDEX intrinsic
    if (index(str(1:str_len), seq(1:seq_len), .true.) == i_start) then
      ends_with = .true.
    else
      ends_with = .false.
    end if

  end function ends_with

!===============================================================================
! COUNT_DIGITS returns the number of digits needed to represent the input
! integer.
!===============================================================================

  pure function count_digits(num) result(n_digits)
    integer, intent(in) :: num
    integer             :: n_digits

    n_digits = 1
    do while (num / 10**(n_digits) /= 0 .and. abs(num / 10 **(n_digits-1)) /= 1&
              &.and. n_digits /= 10)
      ! Note that 10 digits is the maximum needed to represent an integer(4) so
      ! the loop automatically exits when n_digits = 10.
      n_digits = n_digits + 1
    end do

  end function count_digits

!===============================================================================
! INT4_TO_STR converts an integer(4) to a string.
!===============================================================================

  pure function int4_to_str(num) result(str)

    integer, intent(in) :: num
    character(11) :: str

    write (str, '(I11)') num
    str = adjustl(str)

  end function int4_to_str

!===============================================================================
! INT8_TO_STR converts an integer(8) to a string.
!===============================================================================

  pure function int8_to_str(num) result(str)

    integer(8), intent(in) :: num
    character(21) :: str

    write (str, '(I21)') num
    str = adjustl(str)

  end function int8_to_str

!===============================================================================
! REAL_TO_STR converts a real(8) to a string based on how large the value is and
! how many significant digits are desired. By default, six significants digits
! are used.
!===============================================================================

  pure function real_to_str(num, sig_digits) result(string)

    real(8),           intent(in) :: num        ! number to convert
    integer, optional, intent(in) :: sig_digits ! # of significant digits
    character(15)                 :: string     ! string returned

    integer      :: decimal ! number of places after decimal
    integer      :: width   ! total field width
    real(8)      :: num2    ! absolute value of number
    character(9) :: fmt     ! format specifier for writing number

    ! set default field width
    width = 15

    ! set number of places after decimal
    if (present(sig_digits)) then
      decimal = sig_digits
    else
      decimal = 6
    end if

    ! Create format specifier for writing character
    num2 = abs(num)
    if (num2 == 0.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, 1
    elseif (num2 < 1.0e-1_8) then
      write(fmt, '("(ES",I2,".",I2,")")') width, decimal - 1
    elseif (num2 >= 1.0e-1_8 .and. num2 < 1.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, decimal
    elseif (num2 >= 1.0_8 .and. num2 < 10.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, max(decimal-1, 0)
    elseif (num2 >= 10.0_8 .and. num2 < 100.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, max(decimal-2, 0)
    elseif (num2 >= 100.0_8 .and. num2 < 1000.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, max(decimal-3, 0)
    elseif (num2 >= 100.0_8 .and. num2 < 10000.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, max(decimal-4, 0)
    elseif (num2 >= 10000.0_8 .and. num2 < 100000.0_8) then
      write(fmt, '("(F",I2,".",I2,")")') width, max(decimal-5, 0)
    else
      write(fmt, '("(ES",I2,".",I2,")")') width, decimal - 1
    end if

    ! Write string and left adjust
    write(string, fmt) num
    string = adjustl(string)

  end function real_to_str

!===============================================================================
! STR_TO_INT converts a string to an integer.
!===============================================================================

  pure function str_to_int(str) result(num)

    character(*), intent(in) :: str
    integer(8) :: num

    character(5) :: fmt
    integer      :: w
    integer      :: ioError

    ! Determine width of string
    w = len_trim(str)

    ! Create format specifier for reading string
    write(UNIT=fmt, FMT='("(I",I2,")")') w

    ! read string into integer
    read(UNIT=str, FMT=fmt, IOSTAT=ioError) num
    if (ioError > 0) num = ERROR_INT

  end function str_to_int

!===============================================================================
! STR_TO_REAL converts an arbitrary string to a real(8)
!===============================================================================

  pure function str_to_real(string) result(num)

    character(*), intent(in) :: string
    real(8)                  :: num

    integer :: ioError

    ! Read string
    read(UNIT=string, FMT=*, IOSTAT=ioError) num
    if (ioError > 0) num = ERROR_REAL

  end function str_to_real

!===============================================================================
! CONCATENATE takes an array of words and concatenates them together in one
! string with a single space between words
!
! Arguments:
!   words   = array of words
!   n_words = total number of words
!   string  = concatenated string
!===============================================================================

  pure function concatenate(words, n_words) result(string)

    integer,        intent(in)  :: n_words
    character(*),   intent(in)  :: words(n_words)
    character(MAX_LINE_LEN)     :: string

    integer :: i ! index

    string = words(1)
    if (n_words == 1) return
    do i = 2, n_words
      string = trim(string) // ' ' // words(i)
    end do

  end function concatenate

end module simple_string