#!/usr/bin/env python2

'''Python script to plot tally data generated by OpenMC.'''

import sys
from statepoint import *

# Color intensity dependent on individual score?

from PyQt4.QtCore import *
from PyQt4.QtGui import *
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar
import numpy as np

class AppForm(QMainWindow):
    def __init__(self, argv, parent=None):
        QMainWindow.__init__(self, parent)

        # Read data from source or leakage fraction file
        self.all_good = False
        while not self.all_good:
            if len(argv) > 1:
                cl_file = str(argv[1])
            else:
                cl_file = None
            self.get_file_data(cl_file)
            # Check that there are any mesh tallies at all
            if len(self.tally_ids) != 0:
                self.all_good = True
            else:
                # if there are not, the user will be given the choice to choose
                # another file (but only if using interactive chooser)
                if cl_file is None:
                    choice = QMessageBox.critical(None, "Invalid StatePoint File",
                                                  "File Does Not Contain Mesh " +
                                                  "Tallies!" +
                                                  "\nSelect Another File Or Quit",
                                                  QMessageBox.Retry,
                                                  QMessageBox.Abort)
                    if choice == QMessageBox.Abort:
                        self.all_good = False
                        break
                else:
                    print("Invalid StatePoint File; File Does Not Contain " +
                          "Mesh Tallies!")
                    self.all_good = False
                    break


        if self.all_good:
            # Set maximum colorbar value by maximum tally data value
            self.maxvalue = self.datafile.tallies[0].results.max()

            self.main_frame = QWidget()
            self.setCentralWidget(self.main_frame)

            # Create the Figure, Canvas, and Axes
            self.dpi = 100
            self.fig = Figure((5.0, 15.0), dpi=self.dpi)
            self.canvas = FigureCanvas(self.fig)
            self.canvas.setParent(self.main_frame)
            self.axes = self.fig.add_subplot(111)

            # Create the navigation toolbar, tied to the canvas
            self.mpl_toolbar = NavigationToolbar(self.canvas, self.main_frame)

            # Grid layout at bottom
            self.grid = QGridLayout()

            # Overall layout
            self.vbox = QVBoxLayout()
            self.vbox.addWidget(self.canvas)
            self.vbox.addWidget(self.mpl_toolbar)
            self.vbox.addLayout(self.grid)
            self.main_frame.setLayout(self.vbox)

            # Tally selections
            label_tally = QLabel("Tally:")
            self.tally = QComboBox()
            # Only show options for the tallies with meshes
            self.tally.addItems([str(i + 1) for i in self.tally_ids])
            self.connect(self.tally, SIGNAL('activated(int)'),
                         self._update)
            self.connect(self.tally, SIGNAL('activated(int)'),
                         self.populate_boxes)
            self.connect(self.tally, SIGNAL('activated(int)'),
                         self.on_draw)

            # Planar basis
            label_basis = QLabel("Basis:")
            self.basis = QComboBox()
            self.basis.addItems(['xy', 'yz', 'xz'])

            # Update window when 'Basis' selection is changed
            self.connect(self.basis, SIGNAL('activated(int)'),
                         self._update)
            self.connect(self.basis, SIGNAL('activated(int)'),
                         self.populate_boxes)
            self.connect(self.basis, SIGNAL('activated(int)'),
                         self.on_draw)

            # Axial level within selected basis
            label_axial_level = QLabel("Axial Level:")
            self.axial_level = QComboBox()
            self.connect(self.axial_level, SIGNAL('activated(int)'),
                         self.on_draw)

            # Add Option to plot mean or uncertainty
            label_mean = QLabel("Mean or Uncertainty:")
            self.mean = QComboBox()
            self.mean.addItems(['Mean','Absolute Uncertainty',
                                'Relative Uncertainty'])

            # Update window when mean selection is changed
            self.connect(self.mean, SIGNAL('activated(int)'),
                         self.on_draw)


            self.label_filters = QLabel("Filter options:")

            # Labels for all possible filters
            self.labels = {'cell': 'Cell: ', 'cellborn': 'Cell born: ',
                           'surface': 'Surface: ', 'material': 'Material',
                           'universe': 'Universe: ', 'energyin': 'Energy in: ',
                           'energyout': 'Energy out: '}

            # Empty reusable labels
            self.qlabels = {}
            for j in range(8):
                self.nextLabel = QLabel
                self.qlabels[j] = self.nextLabel

            # Reusable comboboxes labelled with filter names
            self.boxes = {}
            for key in self.labels.keys():
                self.nextBox = QComboBox()
                self.connect(self.nextBox, SIGNAL('activated(int)'),
                             self.on_draw)
                self.boxes[key] = self.nextBox

            # Combobox to select among scores
            self.score_label = QLabel("Score:")
            self.scoreBox = QComboBox()
            for item in self.tally_scores[0]:
                self.scoreBox.addItems(str(item))
            self.connect(self.scoreBox, SIGNAL('activated(int)'),
                         self.on_draw)

            # Fill layout
            self.grid.addWidget(label_tally, 0, 0)
            self.grid.addWidget(self.tally, 0, 1)
            self.grid.addWidget(label_basis, 1, 0)
            self.grid.addWidget(self.basis, 1, 1)
            self.grid.addWidget(label_axial_level, 2, 0)
            self.grid.addWidget(self.axial_level, 2, 1)
            self.grid.addWidget(label_mean, 3, 0)
            self.grid.addWidget(self.mean, 3, 1)
            self.grid.addWidget(self.label_filters, 4, 0)

            self._update()
            self.populate_boxes()
            self.on_draw()

    def get_file_data(self, cl_file=None):
        # Get data file name from "open file" browser
        if cl_file is None:
            filename = QFileDialog.getOpenFileName(self,
                                                   'Select statepoint file', '.')
        else:
            filename = cl_file

        # Create StatePoint object and read in data
        self.datafile = StatePoint(str(filename))
        self.datafile.read_results()
        self.datafile.generate_stdev()

        self.setWindowTitle('Core Map Tool : ' + str(self.datafile.path))

        self.labelList = []

        # Read mesh dimensions
        # for mesh in self.datafile.meshes:
        #  self.nx, self.ny, self.nz = mesh.dimension

        # Find which tallies have meshes so the rest can be ignored,
        # and for these tallies read the filter and score types
        self.tally_ids = []
        self.n_tallies = len(self.datafile.tallies)
        self.tally_list = []
        self.tally_scores = []
        for itally, tally in enumerate(self.datafile.tallies):
            if 'mesh' in tally.filters:
                # Then we have a good tally, store the ID, filters and
                # scores
                self.tally_ids.append(itally)
                self.filter_types = []
                for f in tally.filters:
                    self.filter_types.append(f)
                self.tally_list.append(self.filter_types)
                self.score_types = []
                for s in tally.scores:
                    self.score_types.append(s)
                self.tally_scores.append(self.score_types)

    def on_draw(self):
        """ Redraws the figure
        """

#        print 'Calling on_draw...'
        # Get selected basis, axial_level and stage
        basis = self.basis.currentIndex() + 1
        axial_level = self.axial_level.currentIndex() + 1
        is_mean = self.mean.currentIndex()

        # get current tally index
        tally_id = self.tally_ids[self.tally.currentIndex()]

        # Create spec_list
        spec_list = []
        for tally in self.datafile.tallies[tally_id].filters.values():
            if tally.type == 'mesh':
                continue
            index = self.boxes[tally.type].currentIndex()
            spec_list.append((tally.type, index))

        # Take is_mean and convert it to an index of the score
        score_loc = is_mean
        if score_loc > 1:
            score_loc = 1

        if self.basis.currentText() == 'xy':
            matrix = np.zeros((self.nx, self.ny))
            for i in range(self.nx):
                for j in range(self.ny):
                    matrix[i,j] = self.datafile.get_value(tally_id,
                        spec_list + [('mesh', (i + 1, j + 1, axial_level))],
                        self.scoreBox.currentIndex())[score_loc]
                    # Calculate relative uncertainty from absolute, if
                    # requested
                    if is_mean == 2:
                        # Take care to handle zero means when normalizing
                        mean_val = self.datafile.get_value(tally_id,
                            spec_list + [('mesh', (i + 1, j + 1, axial_level))],
                            self.scoreBox.currentIndex())[0]
                        if mean_val > 0.0:
                            matrix[i,j] = matrix[i,j] / mean_val
                        else:
                            matrix[i,j] = 0.0

        elif self.basis.currentText() == 'yz':
            matrix = np.zeros((self.ny, self.nz))
            for i in range(self.ny):
                for j in range(self.nz):
                    matrix[i,j] = self.datafile.get_value(tally_id,
                        spec_list + [('mesh', (axial_level, i + 1, j + 1))],
                        self.scoreBox.currentIndex())[score_loc]
                    # Calculate relative uncertainty from absolute, if
                    # requested
                    if is_mean == 2:
                        # Take care to handle zero means when normalizing
                        mean_val = self.datafile.get_value(tally_id,
                            spec_list + [('mesh', (axial_level, i + 1, j + 1))],
                            self.scoreBox.currentIndex())[0]
                        if mean_val > 0.0:
                            matrix[i,j] = matrix[i,j] / mean_val
                        else:
                            matrix[i,j] = 0.0

        else:
            matrix = np.zeros((self.nx, self.nz))
            for i in range(self.nx):
                for j in range(self.nz):
                    matrix[i,j] = self.datafile.get_value(tally_id,
                        spec_list + [('mesh', (i + 1, axial_level, j + 1))],
                        self.scoreBox.currentIndex())[score_loc]
                    # Calculate relative uncertainty from absolute, if
                    # requested
                    if is_mean == 2:
                        # Take care to handle zero means when normalizing
                        mean_val = self.datafile.get_value(tally_id,
                            spec_list + [('mesh', (i + 1, axial_level, j + 1))],
                            self.scoreBox.currentIndex())[0]
                        if mean_val > 0.0:
                            matrix[i,j] = matrix[i,j] / mean_val
                        else:
                            matrix[i,j] = 0.0

#        print spec_list

        # Clear the figure
        self.fig.clear()

        # Make figure, set up color bar
        self.axes = self.fig.add_subplot(111)
        cax = self.axes.imshow(matrix.transpose(), vmin=0.0, vmax=matrix.max(),
          interpolation="nearest", origin='lower')
        self.fig.colorbar(cax)

        self.axes.set_xticks([])
        self.axes.set_yticks([])
        self.axes.set_aspect('equal')

        # Draw canvas
        self.canvas.draw()

    def _update(self):
        '''Updates widget to display new relevant comboboxes and figure data
        '''
#        print 'Calling _update...'

        # get current tally index
        tally_id = self.tally_ids[self.tally.currentIndex()]

        self.mesh = self.datafile.meshes[
          self.datafile.tallies[tally_id].filters['mesh'].bins[0] - 1]

        self.nx, self.ny, self.nz = self.mesh.dimension

        # Clear axial level combobox
        self.axial_level.clear()

        # Repopulate axial level combobox based on current basis selection
        if (self.basis.currentText() == 'xy'):
            self.axial_level.addItems([str(i+1) for i in range(self.nz)])
        elif (self.basis.currentText() == 'yz'):
            self.axial_level.addItems([str(i+1) for i in range(self.nx)])
        else:
            self.axial_level.addItems([str(i+1) for i in range(self.ny)])

        # Determine maximum value from current tally data set
        self.maxvalue = self.datafile.tallies[tally_id].results.max()
#        print self.maxvalue

        # Clear and hide old filter labels
        for item in self.labelList:
            item.clear()

        # Clear and hide old filter boxes
        for j in self.labels:
            self.boxes[j].clear()
            self.boxes[j].setParent(None)

        self.update()

    def populate_boxes(self):
#        print 'Calling populate_boxes...'

        # get current tally index
        tally_id = self.tally_ids[self.tally.currentIndex()]

        n = 5
        labels = {'cell': 'Cell : ',
                       'cellborn': 'Cell born: ',
                       'surface': 'Surface: ',
                       'material': 'Material: ',
                       'universe': 'Universe: '}

        # For each filter in newly-selected tally, name a label and fill the
        # relevant combobox with options
        for element in self.tally_list[self.tally.currentIndex()]:
            nextFilter = self.datafile.tallies[tally_id].filters[element]
            if element == 'mesh':
                continue

            label = QLabel(self.labels[element])
            self.labelList.append(label)
            combobox = self.boxes[element]
            self.grid.addWidget(label, n, 0)
            self.grid.addWidget(combobox, n, 1)
            n += 1

#            print element
            if element in ['cell', 'cellborn', 'surface', 'material', 'universe']:
                combobox.addItems([str(i) for i in nextFilter.bins])
#                for i in nextFilter.bins:
#                    print i

            elif element == 'energyin' or element == 'energyout':
                for i in range(nextFilter.length):
                    text = (str(nextFilter.bins[i]) + ' to ' +
                      str(nextFilter.bins[i+1]))
                    combobox.addItem(text)

        self.scoreBox.clear()
        for item in self.tally_scores[self.tally.currentIndex()]:
            self.scoreBox.addItem(str(item))
        self.grid.addWidget(self.score_label, n, 0)
        self.grid.addWidget(self.scoreBox, n, 1)



def main():
    app = QApplication(sys.argv)
    form = AppForm(app.arguments())
    if form.all_good:
        form.show()
        app.exec_()


if __name__ == "__main__":
    main()
